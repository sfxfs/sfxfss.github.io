<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WSL下编译rv110x系列芯片固件</title>
      <link href="/2024/11/20/WSL%20%E4%B8%8B%E7%BC%96%E8%AF%91%20rv110x%20%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87%E5%9B%BA%E4%BB%B6/"/>
      <url>/2024/11/20/WSL%20%E4%B8%8B%E7%BC%96%E8%AF%91%20rv110x%20%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87%E5%9B%BA%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>系统使用 Windows 11 WSL2 Ubuntu 24.04</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="一、没有-python-这个命令"><a href="#一、没有-python-这个命令" class="headerlink" title="一、没有 python 这个命令"></a>一、没有 python 这个命令</h3><p>是因为安装了 python3 但没有 python 没有指向它</p><p><code>sudo apt install python-is-python3</code></p><p>安装该包来解决这个问题</p><h3 id="二、PATH-包含空格"><a href="#二、PATH-包含空格" class="headerlink" title="二、PATH 包含空格"></a>二、PATH 包含空格</h3><p>WSL 把 windows 的 PATH 也一起弄到 Linux 内了</p><p>修改 WSL 配置文件 <code>/etc/wsl.conf</code> 添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[interop]</span><br><span class="line">appendWindowsPath=false</span><br></pre></td></tr></table></figure><p>关闭 wsl 八秒以上再启动即可解决</p><h3 id="三、找不到-cpio-模块"><a href="#三、找不到-cpio-模块" class="headerlink" title="三、找不到 cpio 模块"></a>三、找不到 cpio 模块</h3><p>安装一下 <code>sudo apt install cpio</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux luckfox rv1103 rv1106 wsl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nanopi neo core 作为下位机首次配置流程</title>
      <link href="/2023/05/03/Nanopi-neo-core-%E4%BD%9C%E4%B8%BA%E4%B8%8B%E4%BD%8D%E6%9C%BA%E9%A6%96%E6%AC%A1%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/05/03/Nanopi-neo-core-%E4%BD%9C%E4%B8%BA%E4%B8%8B%E4%BD%8D%E6%9C%BA%E9%A6%96%E6%AC%A1%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p> <a href="https://detail.yinxiang.com/index.html?guid=ba0bc618-4d29-4d47-ac6c-94ee43c146a3&loginName=zz&token=V1-5045541-MYjTa8q0ZLek6LeI38RvqD5jI24sVIuET6GRx9SRx+6LylYFWfpEohLy/GvK2k1C4rP7Xzg8KW3ITmaY3ABkQrRRKV0qmmvJzOQxupLrrBHjOgO1kKvbb0qVhVeAmkvE/4Zh8sYgbnZuLLj0qaPvTHhnkf37MKJ7Y2i/Ct54j8WhHzSEjBmO0qGrJSZVbxJ0&at=false&platformType=1&deviceinfo=%7B%22application%22:%22android_miniapp%22,%22applicationVersion%22:%221.1.22%22,%22platform%22:%22microsoft%22,%22platformVersion%22:%22Windows%2011%20x64%22,%22locale%22:%22zh_CN%22%7D&unionId=f5d82db79639969b9e276eb18f7d6c98&userId=36590286&sessionId=011Yboll2OePB94SKHll2I8bMS3Ybol1&channelId=wx75425a38a3ed6402">原本的配置流程链接</a></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ol><li>NanoPi NEO Core 板子</li><li>4G 及以上的 TF 卡和读卡器</li><li>USB 转串口</li><li>水下机器人主板（提供网口和供电）</li></ol><h2 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h2><ol><li>安装 SSH 软件（较新的 Windows 系统一般自带，也可以去下载专门的 SSH 软件，如：<code>putty</code> 、<code>finalshell</code>、<code>MobXterm</code>等等）</li><li>串口终端（如 <code>putty</code> 、<code>MobXterm</code> 等等）</li><li>前往 <a href="https://wiki.friendlyelec.com/wiki/index.php/NanoPi_NEO_Core/zh">官方 WiKi</a> 下载系统镜像，注意要下载 带 eflasher 的 Ubuntu xenial 4.14 ，即文件名类似于 <code>h3_ eflasher friendlycore-xenial_ 4.14_ armhf 20210618.img.zip</code> 的镜像文件</li></ol><h1 id="开始烧录固件"><a href="#开始烧录固件" class="headerlink" title="开始烧录固件"></a>开始烧录固件</h1><p>（全新的 Nano Pi 会内置该固件，可以直接跳到<strong>系统配置</strong>）</p><h2 id="向-SD-卡写入镜像"><a href="#向-SD-卡写入镜像" class="headerlink" title="向 SD 卡写入镜像"></a>向 SD 卡写入镜像</h2><p>使用镜像写入工具（如 <code>win32diskimager</code>），选择指定镜像烧录（烧录前请确保 SD 卡只有一个分区）</p><h2 id="使用串口连接-Nano-Pi"><a href="#使用串口连接-Nano-Pi" class="headerlink" title="使用串口连接 Nano Pi"></a>使用串口连接 Nano Pi</h2><p>请将 USB 转串口连接到 Nano Pi 的 RX0 和 TX0 引脚，并且共地，引脚图如下：</p><p><img src="https://wiki.friendlyelec.com/wiki/images/5/53/NEO_Core_pinout-02.jpg"></p><h2 id="电脑连接SBC"><a href="#电脑连接SBC" class="headerlink" title="电脑连接SBC"></a>电脑连接SBC</h2><ol><li><p>将烧录好的 SD 卡插入 Nano Pi</p></li><li><p>使用 Nano Pi 上的 USB 给板子供电</p></li><li><p>将 USB 转串口连接到电脑的串口终端</p></li><li><p>输入账户密码进行登陆（用户账号和密码都是 <code>pi</code> ，root 用户密码是 <code>fa</code>），进入系统后在终端输入 <code>su root</code> 切换 root 用户，后执行 <code>eflasher</code> 命令进入如下界面：<img src="https://wiki.friendlyelec.com/wiki/images/0/09/Eflasher_friendlycore1.jpg"></p></li><li><p>输入“１”后按回车，选择烧写 friendlycore 系统到 eMMC 上后，会提示如下信息：<img src="https://wiki.friendlyelec.com/wiki/images/6/60/Eflasher_friendlycore2_h3.jpg"></p></li><li><p>输入“yes”，确定进行烧写：</p><p><img src="https://wiki.friendlyelec.com/wiki/images/0/0c/Eflasher_friendlycore3.jpg"></p></li><li><p>等待烧写完毕后，断电并从卡槽中取出 TF 卡。</p></li></ol><h1 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h1><h2 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h2><p>将 Nano Pi 插入调试主板后，给其供电并连接网口至路由器</p><h2 id="电脑端操作"><a href="#电脑端操作" class="headerlink" title="电脑端操作"></a>电脑端操作</h2><ol><li><p>到路由器后台查看 Nano Pi 的 IP 地址，使用 SSH 工具连接至 Nano Pi （用户账号和密码都是 <code>pi</code> ，root 用户密码是 <code>fa</code>）</p></li><li><p>更换国内软件源，终端输入 <code>sudo nano /etc/apt/sources.list</code> 后修改为如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial main restricted universe multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ xenial-updates main restricted universe multiverse</span><br></pre></td></tr></table></figure></li><li><p>更新软件源（依次输入以下命令）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get clean</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment">#可能需要较长时间，期间不能关闭 SSH 连接</span></span><br></pre></td></tr></table></figure></li><li><p>安装必备软件（依次输入以下命令）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gdb htop cmake unzip i2c-tools autoconf automake libtool</span><br><span class="line"></span><br><span class="line">sudo apt-get install libgstreamer*</span><br><span class="line"></span><br><span class="line">sudo apt-get install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa gstreamer1.0-pulseaudio</span><br><span class="line"></span><br><span class="line"><span class="comment">#可能有些软件包找不到了，请在命令中删除那些软件包的名字再尝试安装</span></span><br></pre></td></tr></table></figure></li><li><p>到 Github 下载 rovmaster 的源码 zip 压缩包，使用网络传输到 Nano Pi ，在 SSH 终端中使用 <code>unzip</code> 命令进行解压</p></li><li><p>解压后进入 <strong>rov-master-main</strong> 文件夹，输入 <code>sudo chmod +x build.sh</code> 后输入 <code>sudo ./build.sh</code> 进行依赖编译</p></li><li><p>显示 <em>构建完成</em> 后，输入命令 <code>make</code> 后<strong>没有错误</strong>后，再输入一次 <code>make</code> 就会产生可执行文件 <code>rovmaster</code></p></li><li><p>使能 <code>spi1</code> 外设，输入 <code>udo npi-config</code> 命令后到 <code>\&gt; Advanced Options</code> 中使能相关 SPI 设备</p></li><li><p>修改静态 IP ，输入命令 <code>sudo nano /etc/network/interfaces</code> 后将原文件内容注释掉后加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allow-hotplug eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.137.219</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.137.1</span><br><span class="line">dns-nameservers 192.168.137.1</span><br></pre></td></tr></table></figure></li><li><p>配置结束</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> linux nanopi SBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RockPi 5B Armbian 首次开机设置流程</title>
      <link href="/2023/04/03/RockPi-5B-Armbian-%E9%A6%96%E6%AC%A1%E5%BC%80%E6%9C%BA%E8%AE%BE%E7%BD%AE%E6%B5%81%E7%A8%8B/"/>
      <url>/2023/04/03/RockPi-5B-Armbian-%E9%A6%96%E6%AC%A1%E5%BC%80%E6%9C%BA%E8%AE%BE%E7%BD%AE%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="镜像烧录"><a href="#镜像烧录" class="headerlink" title="镜像烧录"></a>镜像烧录</h2><p>下载 Armbian 最新镜像 <em>Armbian_x.x.x_Rock-5b_jammy_legacy_x.x.x_gnome_desktop.img.xz</em> 烧录到SD内（推荐使用 Raspberry Pi Imager）</p><h2 id="安装后相关设置"><a href="#安装后相关设置" class="headerlink" title="安装后相关设置"></a>安装后相关设置</h2><ol><li><p>首先启动3D加速</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:liujianfeng1994/panfork-mesa</span><br><span class="line">sudo add-apt-repository ppa:liujianfeng1994/rockchip-multimedia</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt dist-upgrade</span><br><span class="line">sudo apt install kodi</span><br></pre></td></tr></table></figure></li><li><p>如果要使用Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --<span class="built_in">set</span> iptables /usr/sbin/iptables-legacy</span><br><span class="line">update-alternatives --<span class="built_in">set</span> ip6tables /usr/sbin/ip6tables-legacy</span><br></pre></td></tr></table></figure></li><li><p>安装中文字体（后把shell改为中文才不会乱码）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ttf-wqy-microhei</span><br><span class="line">sudo apt-get install ttf-wqy-zenhei</span><br></pre></td></tr></table></figure><p>需要GUI(Gnome)也为中文可以到设置里切换语言，会自动安装</p></li><li><p>安装风扇接口驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lukaszsobala/fan-control-rock5b</span><br><span class="line"><span class="built_in">cd</span> fan-control-rock5b</span><br><span class="line">make package</span><br><span class="line">sudo dpkg -i fan-control*.deb</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> fan-control</span><br><span class="line">systemctl start fan-control</span><br></pre></td></tr></table></figure></li><li><p>安装HDMI采集卡驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gstreamer1.0-rockchip1 gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly</span><br></pre></td></tr></table></figure><p>4K查看(请在显卡控制菜单中选择yuv420格式输出):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gst-launch-1.0 -e v4l2src device=/dev/video0 ! videoconvert ! <span class="string">&#x27;video/x-raw,format=NV12,width=3840,height=2160&#x27;</span> ! autovideosink</span><br></pre></td></tr></table></figure><p>4K录制+监看(请在显卡控制菜单中选择yuv420格式输出):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gst-launch-1.0 -e v4l2src device=/dev/video0 ! <span class="string">&#x27;video/x-raw,format=NV12,width=3840,height=2160&#x27;</span> ! <span class="built_in">tee</span> name=t t. ! mpph265enc bps=20000000 bps-max=40000000 rc-mode=vbr ! h265parse ! mp4mux name=mux ! filesink location=4k60hdmiin.mp4 alsasrc device=default ! opusenc bitrate=192000 ! mux. t. ! queue leaky=1 ! autovideosink <span class="built_in">sync</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ol><p>想要修改视频码率请更改mpph265enc bps&#x3D;和bps-max&#x3D;,单位bit&#x2F;s<br>修改音频码率请更改opusenc bitrate&#x3D;,单位bit&#x2F;s<br>不需要录音或开启录制后卡死可以把<code>alsasrc device=default ! opusenc bitrate=192000 ! mux.</code> 删掉<br>不需要监看可以把<code>t. ! queue leaky=1 ! autovideosink sync=false</code>删掉<br>需要h264格式请把mpph265enc改成mpph264enc 并把h265parse改成h264parse<br>如果报错<code>streaming stopped, reason not-negotiated (-4)</code> 首先运行dmesg看看有没有报错刷屏, 如果有,那么建议换一根好点的HDMI线. 否则检查电脑输出分辨率和格式.<br>想要其它格式和分辨率要把<code>&#39;video/x-raw,format=NV12,width=3840,height=2160&#39;</code>作对应修改! 其中format建议NV12&#x2F;NV16&#x2F;BGR&#x2F;RGB挨个试一遍<br>1080p下采集的刷新率其实不受限于60Hz, 可以在电脑上自行修改.</p><ol start="6"><li><p>A8型号的蓝牙驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">nano /etc/modprobe.d/blacklist.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#最后一行加上以下这些</span></span><br><span class="line">blacklist pgdrv</span><br><span class="line">blacklist btusb</span><br><span class="line">blacklist btrtl</span><br><span class="line">blacklist btbcm</span><br><span class="line">blacklist btintel</span><br><span class="line"></span><br><span class="line">systemctl restart bluetooth</span><br></pre></td></tr></table></figure></li><li><p>其他定制设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo armbian-config</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> linux RockPi Armbian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-IDF WIFI的使用(1) 初步入门</title>
      <link href="/2023/01/03/ESP32-IDF-WIFI%E7%9A%84%E4%BD%BF%E7%94%A8-1-%E5%88%9D%E6%AD%A5%E5%85%A5%E9%97%A8/"/>
      <url>/2023/01/03/ESP32-IDF-WIFI%E7%9A%84%E4%BD%BF%E7%94%A8-1-%E5%88%9D%E6%AD%A5%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>WiFi相关文档参阅 <a href="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v5.0/esp32/api-guides/wifi.html">乐鑫IDF编程文档</a></p><p>具体启动流程如下:</p><p><img src="https://docs.espressif.com/projects/esp-idf/zh_CN/release-v5.0/esp32/_images/seqdiag-3539a23193af2f08aeb412fd527f18a5a1b2fd43.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ESP_ERROR_CHECK(esp_netif_init());  <span class="comment">//创建一个 LwIP 核心任务，并初始化 LwIP 相关工作</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_event_loop_create_default());   <span class="comment">//创建一个系统事件任务，并初始化应用程序事件的回调函数。在此情况下，该回调函数唯一的动作就是将事件中继到应用程序任务中</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_netif_create_default_wifi_sta());   <span class="comment">//创建有 TCP/IP 堆栈的默认网络接口实例绑定 station</span></span><br><span class="line">    <span class="type">wifi_init_config_t</span> wifi_init_config = WIFI_INIT_CONFIG_DEFAULT;</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_init(&amp;wifi_init_config));</span><br><span class="line"></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));</span><br><span class="line"></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_start());</span><br><span class="line"></span><br><span class="line">    <span class="type">wifi_country_t</span> country_config = &#123;</span><br><span class="line">        .cc = <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">        .schan = <span class="number">1</span>,</span><br><span class="line">        .nchan = <span class="number">13</span>,</span><br><span class="line">        .policy = WIFI_COUNTRY_POLICY_AUTO,</span><br><span class="line">    &#125;;</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_country(&amp;country_config));</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 IDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-IDF 自定义分区表的编写</title>
      <link href="/2023/01/02/ESP32-IDF-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9A%84%E7%BC%96%E5%86%99/"/>
      <url>/2023/01/02/ESP32-IDF-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E5%8C%BA%E8%A1%A8%E7%9A%84%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Name,   Type, SubType, Offset,  Size, Flags</span><br><span class="line">nvs,      data, nvs,     ,        0x6000,</span><br><span class="line">phy_init, data, phy,     ,        0x1000,</span><br><span class="line">factory,  app,  factory, ,        1M,</span><br></pre></td></tr></table></figure><p>第一个为NVS分区,大小为24K多一点;第三个就是存放程序的地方,大小为1MByte</p><p>我们在底下多加一行NVS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_nvs, data, nvs, , 1M,</span><br></pre></td></tr></table></figure><p>将这些内容保存为 <code>partitions.csv</code> 后放在项目根目录并修改 Manuconfig 里面使用的分区表.</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>这里以NVS为例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">nvs_handle_t</span> testhandle;</span><br><span class="line">nvs_open_from_partition(<span class="string">&quot;my_nvs&quot;</span>, <span class="string">&quot;test_name&quot;</span>, NVS_READWRITE, &amp;testhandle);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 IDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-IDF 非易失性存储 NVS (二) 相关工具</title>
      <link href="/2023/01/02/ESP32-IDF-%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8-NVS-%E4%BA%8C-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/01/02/ESP32-IDF-%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8-NVS-%E4%BA%8C-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="NVS迭代器"><a href="#NVS迭代器" class="headerlink" title="NVS迭代器"></a>NVS迭代器</h1><p>相当于终端的 <code>ls</code> 命令,可以遍历 NVS 所有的 key 和 value</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example of listing all the key-value pairs of any type under specified partition and namespace</span></span><br><span class="line"> <span class="type">nvs_iterator_t</span> it = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="type">esp_err_t</span> res = nvs_entry_find(&lt;nvs_partition_name&gt;, &lt;namespace&gt;, NVS_TYPE_ANY, &amp;it);</span><br><span class="line"> <span class="keyword">while</span>(res == ESP_OK) &#123;</span><br><span class="line">     <span class="type">nvs_entry_info_t</span> info;</span><br><span class="line">     nvs_entry_info(it, &amp;info); <span class="comment">// Can omit error check if parameters are guaranteed to be non-NULL</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;key &#x27;%s&#x27;, type &#x27;%d&#x27; \n&quot;</span>, info.key, info.type);</span><br><span class="line">     res = nvs_entry_next(&amp;it);</span><br><span class="line"> &#125;</span><br><span class="line"> nvs_release_iterator(it);</span><br></pre></td></tr></table></figure><h1 id="获取NVS当前状态"><a href="#获取NVS当前状态" class="headerlink" title="获取NVS当前状态"></a>获取NVS当前状态</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example of nvs_get_stats() to get the number of used entries and free entries:</span></span><br><span class="line"><span class="type">nvs_stats_t</span> nvs_stats;</span><br><span class="line">nvs_get_stats(<span class="literal">NULL</span>, &amp;nvs_stats);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Count: UsedEntries = (%d), FreeEntries = (%d), AllEntries = (%d)\n&quot;</span>,</span><br><span class="line">       nvs_stats.used_entries, nvs_stats.free_entries, nvs_stats.total_entries);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 IDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-IDF 非易失性存储 NVS (一) 入门</title>
      <link href="/2022/12/19/ESP32-IDF-%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8-NVS-%E4%B8%80-%E5%85%A5%E9%97%A8/"/>
      <url>/2022/12/19/ESP32-IDF-%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8-NVS-%E4%B8%80-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>NVS格式就是一种flash的文件管理方式，因为他自身这种键值对的数据结构有较大的空间开销，所有不适合很长的数据（重复的key会浪费空间），而适合一对一对的这种短的数据（优势应该是方便查管理）.在ESP32上NVS是基础，比如WIFI都会使用到NVS来存储配置文件。<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/api-reference/storage/nvs_flash.html">乐鑫官方文档</a></p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><table><thead><tr><th>函数名</th><th>描述</th></tr></thead><tbody><tr><td>nvs_flash_init()</td><td>挂载NVS</td></tr><tr><td>nvs_flash_deinit()</td><td>卸载NVS</td></tr><tr><td>nvs_open(const char* namespace_name, nvs_open_mode_t open_mode, nvs_handle_t *out_handle)</td><td>打开对应namespace的NVS</td></tr><tr><td>nvs_close(nvs_handle_t *out_handle)</td><td>关闭NVS</td></tr><tr><td>nvs_get_xx(nvs_handle_t c_handle, const char* key, xx* out_value)</td><td>获取数据(如果对应key数据不存在则out_value不会被修改)</td></tr><tr><td>nvs_set_xx(nvs_handle_t handle, const char* key, xx value))</td><td>写入数据</td></tr><tr><td>nvs_commit(nvs_handle_t handle)</td><td>写入所有数据(加在所有set后面)</td></tr></tbody></table><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvs_flash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NS_TEST <span class="string">&quot;ns-test&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_TEST <span class="string">&quot;key-test&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">nvs_handle_t</span> testhandle;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    vTaskDelay(<span class="number">1000</span>/portTICK_PERIOD_MS);</span><br><span class="line">    nvs_flash_init();</span><br><span class="line">    nvs_open(NS_TEST, NVS_READWRITE, &amp;testhandle);</span><br><span class="line">    nvs_get_u16(testhandle, KEY_TEST, &amp;count);</span><br><span class="line">    ESP_LOGI(<span class="string">&quot;NVS&quot;</span>, <span class="string">&quot;the count %d&quot;</span>, count);</span><br><span class="line">    nvs_set_u16(testhandle, KEY_TEST, ++count);</span><br><span class="line">    nvs_commit(testhandle);</span><br><span class="line">    nvs_close(testhandle);</span><br><span class="line">    nvs_flash_deinit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BLOB"><a href="#BLOB" class="headerlink" title="BLOB"></a>BLOB</h1><p>可以存放任何类型的数据,如结构体和字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> <span class="title function_">nvs_set_blob</span><span class="params">(<span class="type">nvs_handle_t</span> c_handle,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="type">char</span>* key,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="type">void</span>* value,</span></span><br><span class="line"><span class="params">                       <span class="type">size_t</span> length)</span></span><br></pre></td></tr></table></figure><p>用法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> ssid[<span class="number">50</span>];</span><br><span class="line">    <span class="type">char</span> password[<span class="number">50</span>];</span><br><span class="line">&#125; <span class="type">ap_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ap_t</span> ap1;</span><br><span class="line"><span class="type">ap_t</span> aps[max_ap];</span><br><span class="line"></span><br><span class="line">nvs_set_blob(my_handle, <span class="string">&quot;test&quot;</span>, ap1, <span class="keyword">sizeof</span>(ap1));</span><br><span class="line">nvs_set_blob(my_handle, <span class="string">&quot;tests&quot;</span>, aps, <span class="keyword">sizeof</span>(aps));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 IDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-IDF 自定义菜单 Menuconfig 入门</title>
      <link href="/2022/12/17/ESP32-IDF-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95-Menuconfig-%E5%85%A5%E9%97%A8/"/>
      <url>/2022/12/17/ESP32-IDF-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95-Menuconfig-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>  程序写好后，肯定会有很多变量需要设置，为了方便他人和未来的自己，我们可以把这些变量做到 Menuconfig 中。这样子，其他人或者未来的自己，就不需要打开代码，直接使用 Menuconfig 配置后，编译再上传即可。</p><p>乐鑫文档; <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/kconfig.html">https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/kconfig.html</a> </p><p>Kconfig 标准; <a href="https://www.kernel.org/doc/html/latest/kbuild/kconfig-language.html">https://www.kernel.org/doc/html/latest/kbuild/kconfig-language.html</a></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>例如下面这段点灯代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LEDPIN 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELAY_MS_TIME 2000</span></span><br><span class="line">...</span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pin_status = <span class="number">0</span>;</span><br><span class="line">    gpio_reset_pin(LEDPIN);</span><br><span class="line">    gpio_set_direction(LEDPIN, GPIO_MODE_OUTPUT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        gpio_set_level(LEDPIN, pin_status);</span><br><span class="line">        vTaskDelay(DELAY_MS_TIME);</span><br><span class="line">        pin_state = !pin_state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时如果需要修改引脚将需要找到对应文件修改代码里面的宏定义，相对来说比较麻烦。</p><h2 id="下面将演示如何通过-Manuconfig-配置"><a href="#下面将演示如何通过-Manuconfig-配置" class="headerlink" title="下面将演示如何通过 Manuconfig 配置:"></a>下面将演示如何通过 Manuconfig 配置:</h2><ul><li>先在main文件夹下创建 <code>Kconfig.projbuild</code> 内容如下:</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">menu <span class="string">&quot;blink_cust&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span> LED_PIN</span><br><span class="line">int</span><br><span class="line">prompt <span class="string">&quot;ESP32上的LED连接到的引脚&quot;</span></span><br><span class="line">range <span class="number">0</span> <span class="number">39</span></span><br><span class="line">default <span class="number">2</span></span><br><span class="line">help</span><br><span class="line">GPIO号码可以通过查阅原理图得知</span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span> DELAY_MS</span><br><span class="line">int</span><br><span class="line">prompt <span class="string">&quot;闪烁间隔时间(MS)&quot;</span></span><br><span class="line">range <span class="number">100</span> <span class="number">10000</span></span><br><span class="line">default <span class="number">1000</span></span><br><span class="line">help</span><br><span class="line">你要设置闪烁的间隔时间</span><br><span class="line"></span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure><ul><li>更改原来的代码</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pin_status = <span class="number">0</span>;</span><br><span class="line">    gpio_reset_pin(LED_PIN);</span><br><span class="line">    gpio_set_direction(LED_PIN, GPIO_MODE_OUTPUT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        gpio_set_level(LED_PIN, pin_status);</span><br><span class="line">        vTaskDelay(DELAY_MS);</span><br><span class="line">        pin_state = !pin_state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 IDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-IDF Cmake编写要点</title>
      <link href="/2022/11/08/ESP32-IDF-Cmake%E7%BC%96%E5%86%99%E8%A6%81%E7%82%B9/"/>
      <url>/2022/11/08/ESP32-IDF-Cmake%E7%BC%96%E5%86%99%E8%A6%81%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="1-文件通配-增量构建"><a href="#1-文件通配-增量构建" class="headerlink" title="1.文件通配 &amp; 增量构建"></a>1.文件通配 &amp; 增量构建</h2><p>在 ESP-IDF 组件中添加源文件的首选方法是在 COMPONENT_SRCS 中手动列出它们:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idf_component_register(SRCS library/a.c library/b.c platform/platform.c</span><br><span class="line">                       ...)</span><br></pre></td></tr></table></figure><p>这是在 CMake 中手动列出源文件的 最佳实践。然而，当有许多源文件都需要添加到构建中时，这种方法就会很不方便。ESP-IDF 构建系统因此提供了另一种替代方法，即使用 SRC_DIRS 来指定源文件:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idf_component_register(SRC_DIRS library platform</span><br><span class="line">                       ...)</span><br></pre></td></tr></table></figure><p>后台会使用通配符在指定的目录中查找源文件。但是请注意，在使用这种方法的时候，如果组件中添加了一个新的源文件，CMake 并不知道重新运行配置，最终该文件也没有被加入构建中。</p><p>如果是自己添加的源文件，这种折衷还是可以接受的，因为用户可以触发一次干净的构建，或者运行 idf.py reconfigure 来手动重启 CMake。但是，如果你需要与其他使用 Git 等版本控制工具的开发人员共享项目时，问题就会变得更加困难，因为开发人员有可能会拉取新的版本。</p><p>ESP-IDF 中的组件使用了第三方的 Git CMake 集成模块（&#x2F;tools&#x2F;cmake&#x2F;third_party&#x2F;GetGitRevisionDescription.cmake），任何时候源码仓库的提交记录发生了改变，该模块就会自动重新运行 CMake。即只要拉取了新的 ESP-IDF 版本，CMake 就会重新运行。</p><p>对于不属于 ESP-IDF 的项目组件，有以下几个选项供参考：</p><p>如果项目文件保存在 Git 中，ESP-IDF 会自动跟踪 Git 修订版本，并在它发生变化时重新运行 CMake。</p><p>如果一些组件保存在第三方 Git 仓库中（不在项目仓库或 ESP-IDF 仓库），则可以在组件 CMakeLists 文件中调用 git_describe 函数，以便在 Git 修订版本发生变化时自动重启 CMake。</p><p><strong>如果没有使用 Git，请记住在源文件发生变化时手动运行 idf.py reconfigure。</strong></p><p>使用 idf_component_register 的 SRCS 参数来列出项目组件中的所有源文件则可以完全避免这一问题。</p><p>具体选择哪一方式，就要取决于项目本身，以及项目用户。</p><h2 id="2-嵌入二进制数据"><a href="#2-嵌入二进制数据" class="headerlink" title="2. 嵌入二进制数据"></a>2. 嵌入二进制数据</h2><p>有时您的组件希望使用一个二进制文件或者文本文件，但是您又不希望将它们重新格式化为 C 源文件。</p><p>这时，您可以在组件注册中指定 EMBED_FILES 参数，用空格分隔要嵌入的文件名称:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idf_component_register(...</span><br><span class="line">                       EMBED_FILES server_root_cert.der)</span><br></pre></td></tr></table></figure><p>或者，如果文件是字符串，则可以使用EMBED_TXTFILES 变量，把文件的内容转成以 null 结尾的字符串嵌入:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idf_component_register(...</span><br><span class="line">                       EMBED_TXTFILES server_root_cert.pem)</span><br></pre></td></tr></table></figure><p>文件的内容会被添加到 Flash 的 .rodata 段，用户可以通过符号名来访问，如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">uint8_t</span> server_root_cert_pem_start[] <span class="keyword">asm</span>(<span class="string">&quot;_binary_server_root_cert_pem_start&quot;</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">uint8_t</span> server_root_cert_pem_end[]   <span class="keyword">asm</span>(<span class="string">&quot;_binary_server_root_cert_pem_end&quot;</span>);</span><br></pre></td></tr></table></figure><p>符号名会根据文件全名生成，如 EMBED_FILES 中所示，字符 &#x2F;、. 等都会被下划线替代。符号名称中的 _binary 前缀由 objcopy 命令添加，对文本文件和二进制文件都是如此。</p><p>如果要将文件嵌入到项目中，而非组件中，可以调用 target_add_binary_data 函数:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target_add_binary_data(myproject.elf <span class="string">&quot;main/data.bin&quot;</span> TEXT)</span><br></pre></td></tr></table></figure><p>文件的内容会被添加到 Flash 的 .rodata 段，用户可以通过符号名来访问，如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">uint8_t</span> server_root_cert_pem_start[] <span class="keyword">asm</span>(<span class="string">&quot;_binary_server_root_cert_pem_start&quot;</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">uint8_t</span> server_root_cert_pem_end[]   <span class="keyword">asm</span>(<span class="string">&quot;_binary_server_root_cert_pem_end&quot;</span>);</span><br></pre></td></tr></table></figure><p>符号名会根据文件全名生成，如 EMBED_FILES 中所示，字符 &#x2F;、. 等都会被下划线替代。符号名称中的 _binary 前缀由 objcopy 命令添加，对文本文件和二进制文件都是如此。<br>如果要将文件嵌入到项目中，而非组件中，可以调用 target_add_binary_data 函数:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target_add_binary_data(myproject.elf <span class="string">&quot;main/data.bin&quot;</span> TEXT)</span><br></pre></td></tr></table></figure><p>并将这行代码放在项目 CMakeLists.txt 的 project() 命令之后，修改 myproject.elf 为你自己的项目名。如果最后一个参数是 TEXT，那么构建系统会嵌入以 null 结尾的字符串，如果最后一个参数被设置为 BINARY，则将文件内容按照原样嵌入。</p><p>有关使用此技术的示例，请查看 file_serving 示例 protocols&#x2F;http_server&#x2F;file_serving&#x2F;main&#x2F;CMakeLists.txt 中的 main 组件，两个文件会在编译时加载并链接到固件中。</p><p>也可以嵌入生成的文件:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(OUTPUT my_processed_file.bin</span><br><span class="line">                  <span class="keyword">COMMAND</span> my_process_file_cmd my_unprocessed_file.bin)</span><br><span class="line">target_add_binary_data(my_target <span class="string">&quot;my_processed_file.bin&quot;</span> BINARY)</span><br></pre></td></tr></table></figure><p>上述示例中，my_processed_file.bin 是通过命令 my_process_file_cmd 从文件 my_unprocessed_file.bin 中生成，然后嵌入到目标中。</p><p>使用 DEPENDS 参数来指明对目标的依赖性:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_target</span>(my_process <span class="keyword">COMMAND</span> ...)</span><br><span class="line">target_add_binary_data(my_target <span class="string">&quot;my_embed_file.bin&quot;</span> BINARY DEPENDS my_process)</span><br></pre></td></tr></table></figure><p>target_add_binary_data 的 DEPENDS 参数确保目标首先执行。</p><p>———-转自IDF官方文档</p>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 IDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(十七)--任务通知3</title>
      <link href="/2022/11/06/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%83-%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A53/"/>
      <url>/2022/11/06/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%83-%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A53/</url>
      
        <content type="html"><![CDATA[<p> 再额外介绍剩下的几个关于任务通知的函数</p><h2 id="1-API介绍"><a href="#1-API介绍" class="headerlink" title="1.API介绍"></a>1.API介绍</h2><ul><li>发送通知</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyAndQuery</span><span class="params">( TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                                 <span class="type">uint32_t</span> ulValue,</span></span><br><span class="line"><span class="params">                                 eNotifyAction eAction,</span></span><br><span class="line"><span class="params">                                 <span class="type">uint32_t</span> *pulPreviousNotifyValue )</span>;</span><br><span class="line"> </span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyAndQueryIndexed</span><span class="params">( TaskHandle_t xTaskToNotify, </span></span><br><span class="line"><span class="params">                                        UBaseType_t uxIndexToNotify, </span></span><br><span class="line"><span class="params">                                        <span class="type">uint32_t</span> ulValue, </span></span><br><span class="line"><span class="params">                                        eNotifyAction eAction, </span></span><br><span class="line"><span class="params">                                        <span class="type">uint32_t</span> *pulPreviousNotifyValue )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyAndQueryFromISR</span><span class="params">( </span></span><br><span class="line"><span class="params">                      TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                      <span class="type">uint32_t</span> ulValue,</span></span><br><span class="line"><span class="params">                      eNotifyAction eAction,</span></span><br><span class="line"><span class="params">                      <span class="type">uint32_t</span> *pulPreviousNotifyValue,</span></span><br><span class="line"><span class="params">                      BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyAndQueryIndexedFromISR</span><span class="params">( </span></span><br><span class="line"><span class="params">                      TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                      UBaseType_t uxIndexToNotify</span></span><br><span class="line"><span class="params">                      <span class="type">uint32_t</span> ulValue,</span></span><br><span class="line"><span class="params">                      eNotifyAction eAction,</span></span><br><span class="line"><span class="params">                      <span class="type">uint32_t</span> *pulPreviousNotifyValue,</span></span><br><span class="line"><span class="params">                      BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">xTaskToNotify</td><td align="center">要通知到的任务的句柄</td></tr><tr><td align="center">ulValue</td><td align="center">通知内容</td></tr><tr><td align="center">eAction</td><td align="center">要执行的操作，内容如上节</td></tr><tr><td align="center">pulPreviousNotifyValue</td><td align="center">返回调用之前的通知内容</td></tr><tr><td align="center">uxIndexToNotify</td><td align="center">要发送到的通知的索引值</td></tr><tr><td align="center">返回值</td><td align="center">只可能返回pdPASS</td></tr></tbody></table><ul><li>（清除）通知状态</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyStateClear</span><span class="params">( TaskHandle_t xTask )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyStateClearIndexed</span><span class="params">( TaskHandle_t xTask, </span></span><br><span class="line"><span class="params">                                          UBaseType_t uxIndexToClear )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyValueClear</span><span class="params">( TaskHandle_t xTask, </span></span><br><span class="line"><span class="params">                                 <span class="type">uint32_t</span> ulBitsToClear )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyValueClearIndexed</span><span class="params">( TaskHandle_t xTask, </span></span><br><span class="line"><span class="params">                                        UBaseType_t uxIndexToClear,</span></span><br><span class="line"><span class="params">                                        <span class="type">uint32_t</span> ulBitsToClear )</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">xTask</td><td align="center">要操作通知的任务句柄</td></tr><tr><td align="center">uxIndexToClear</td><td align="center">操作指定索引值的通知</td></tr><tr><td align="center">ulBitsToClear</td><td align="center">要操作的位</td></tr><tr><td align="center">返回值</td><td align="center">BaseType_t：pdTRUE 或者 pdFALSE ；uint32_t：返回清空之前的通知值</td></tr></tbody></table><p>通过调用 xTaskNotifyStateClear 可以清除通知的“pending”状态，使其恢复可以使用的状态。</p><h2 id="2-程序实例"><a href="#2-程序实例" class="headerlink" title="2. 程序实例"></a>2. 程序实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> ulPreviousValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set bit 8 in the 0th notification value of the task referenced </span></span><br><span class="line"><span class="comment">by xTask1Handle. Store the task&#x27;s previous 0th notification </span></span><br><span class="line"><span class="comment">value (before bit 8 is set) in ulPreviousValue. */</span></span><br><span class="line">xTaskNotifyAndQueryIndexed( xTask1Handle, </span><br><span class="line">                            <span class="number">0</span>, </span><br><span class="line">                            ( <span class="number">1UL</span> &lt;&lt; <span class="number">8UL</span> ), </span><br><span class="line">                            eSetBits, </span><br><span class="line">                            &amp;ulPreviousValue );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Send a notification to the task referenced by xTask2Handle, </span></span><br><span class="line"><span class="comment">potentially removing the task from the Blocked state, but without </span></span><br><span class="line"><span class="comment">updating the task&#x27;s notification value.  Store the tasks notification </span></span><br><span class="line"><span class="comment">value in ulPreviousValue. */</span></span><br><span class="line">xTaskNotifyAndQuery( xTask2Handle, <span class="number">0</span>, eNoAction, &amp;ulPreviousValue );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the notification value of the task referenced by xTask3Handle </span></span><br><span class="line"><span class="comment">to 0x50, even if the task had not read its previous notification value. </span></span><br><span class="line"><span class="comment">The task&#x27;s previous notification value is of no interest so the last </span></span><br><span class="line"><span class="comment">parameter is set to NULL. */</span></span><br><span class="line">xTaskNotifyAndQuery( xTask3Handle, <span class="number">0x50</span>, eSetValueWithOverwrite,  <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the notification value of the task referenced by xTask4Handle </span></span><br><span class="line"><span class="comment">to 0xfff,</span></span><br><span class="line"><span class="comment">but only if to do so would not overwrite the task&#x27;s existing notification</span></span><br><span class="line"><span class="comment">value before the task had obtained it (by a call to xTaskNotifyWait()</span></span><br><span class="line"><span class="comment">or ulTaskNotifyTake()).  The task&#x27;s previous notification value is saved</span></span><br><span class="line"><span class="comment">in ulPreviousValue. */</span></span><br><span class="line"><span class="keyword">if</span>( xTaskNotifyAndQuery( xTask4Handle,</span><br><span class="line">                         <span class="number">0xfff</span>,</span><br><span class="line">                         eSetValueWithoutOverwrite,</span><br><span class="line">                         &amp;ulPreviousValue ) == pdPASS )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* The task&#x27;s notification value was updated. */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* The task&#x27;s notification value was not updated. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(十六)--任务通知2</title>
      <link href="/2022/11/06/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%85%AD-%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A52/"/>
      <url>/2022/11/06/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%85%AD-%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A52/</url>
      
        <content type="html"><![CDATA[<p>今天讲给大家演示如何使用直接任务通知来取代事件组的功能。 任务通知使用的是32bits，而之前讲的事件组是24bits，所以，只要不是涉及多个任务， 那么这个直接任务通知可以完全取代事件组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> TaskHandle_t xledTask = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESET_0  0b1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_1 0b10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_2 0b100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_3 0b1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_4 0b10000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_5 0b100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_6 0b1000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_7 0b10000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_8 0b100000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDBIT_9 0b1000000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟电话键盘的实现代码是抄的。</span></span><br><span class="line"><span class="comment">// 哪位大神有这个产品的链接，我来100个，实在是太复古了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dialTask</span><span class="params">(<span class="type">void</span> * pvParam)</span> &#123;</span><br><span class="line">  <span class="type">const</span> byte INDIALPIN = <span class="number">33</span>;</span><br><span class="line">  <span class="type">const</span> byte PULSEPIN = <span class="number">32</span>;</span><br><span class="line">  pinMode(INDIALPIN, INPUT_PULLUP);</span><br><span class="line">  pinMode(PULSEPIN, INPUT_PULLUP);</span><br><span class="line"></span><br><span class="line">  byte counter = <span class="number">0</span>;</span><br><span class="line">  boolean inDialPinLastState;</span><br><span class="line">  boolean pulsPinLastState;</span><br><span class="line"></span><br><span class="line">  inDialPinLastState = digitalRead(INDIALPIN);</span><br><span class="line">  pulsPinLastState = digitalRead(PULSEPIN);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    boolean inDialPinState = digitalRead(INDIALPIN);</span><br><span class="line">    boolean pulsPinState = digitalRead(PULSEPIN);</span><br><span class="line">    <span class="keyword">if</span> (inDialPinState != inDialPinLastState) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!inDialPinState) &#123;</span><br><span class="line">        counter = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (counter) &#123;</span><br><span class="line">          counter = counter % <span class="number">10</span>;</span><br><span class="line">          <span class="comment">// ---- 横线上方Dial的判断代码为抄的 ----</span></span><br><span class="line">          <span class="comment">// Serial.println(counter);</span></span><br><span class="line">          <span class="type">uint32_t</span> ulEventGroup;</span><br><span class="line">          <span class="keyword">switch</span> (counter) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: ulEventGroup = RESET_0 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: ulEventGroup = LEDBIT_1 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: ulEventGroup = LEDBIT_2 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: ulEventGroup = LEDBIT_3 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: ulEventGroup = LEDBIT_4 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: ulEventGroup = LEDBIT_5 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>: ulEventGroup = LEDBIT_6 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>: ulEventGroup = LEDBIT_7 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>: ulEventGroup = LEDBIT_8 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>: ulEventGroup = LEDBIT_9 ; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: ulEventGroup = RESET_0 ; <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          xTaskNotify( xledTask,</span><br><span class="line">                       ulEventGroup,</span><br><span class="line">                       eSetBits);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// ---- 横线下方Dial的判断代码为抄的 ----</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      inDialPinLastState = inDialPinState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pulsPinLastState != pulsPinState) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!pulsPinLastState) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">      &#125;</span><br><span class="line">      pulsPinLastState = pulsPinState;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ledTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> &#123;</span><br><span class="line"></span><br><span class="line">  byte led_pins[<span class="number">9</span>] = &#123;<span class="number">23</span>, <span class="number">22</span>, <span class="number">21</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (byte pin : led_pins) pinMode(pin, OUTPUT);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> ulNotifiedValue;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    xTaskNotifyWait( pdFALSE,    <span class="comment">/* Don&#x27;t clear bits on entry. */</span></span><br><span class="line">                     ULONG_MAX,        <span class="comment">/* Clear all bits on exit. */</span></span><br><span class="line">                     &amp;ulNotifiedValue, <span class="comment">/* Stores the notified value. */</span></span><br><span class="line">                     portMAX_DELAY );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第0位 为 0 熄灭所有灯</span></span><br><span class="line">    <span class="keyword">if</span> (ulNotifiedValue &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        digitalWrite(led_pins[i - <span class="number">1</span>], LOW);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对0-9位进行判断，如果第一位是1，那么点亮第一个LED，以此类推</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ulNotifiedValue &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">        digitalWrite(led_pins[i - <span class="number">1</span>], HIGH);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line"></span><br><span class="line">  xTaskCreate(dialTask, <span class="string">&quot;Dial Panel&quot;</span>, <span class="number">1024</span> * <span class="number">10</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">  xTaskCreate(ledTask, <span class="string">&quot;Nine LED&quot;</span>, <span class="number">1024</span> * <span class="number">10</span>, <span class="literal">NULL</span>, <span class="number">1</span>, &amp;xledTask);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(十五)--任务通知1</title>
      <link href="/2022/11/04/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%BA%94-%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A51/"/>
      <url>/2022/11/04/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%BA%94-%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A51/</url>
      
        <content type="html"><![CDATA[<p>Direct Task Notification是FreeRTOS 10版本以后的最重要的一个功能。他可以实现大部分二进制信号量，计数信号量，事件组，邮箱等等的功能。而且速度快45%，并且占用更少的内存，所以我们应该尽量使用任务通知这个功能。本集会深层次的讲解什么是notification，以及对他的读，写 和等待。一个任务将会有多个通知，一个通知包含<strong>值（value）</strong>以及<strong>状态（status）</strong>这两个内容，<strong>值</strong>占4个字节，<strong>状态</strong>占一个字节。</p><h2 id="1-API介绍"><a href="#1-API介绍" class="headerlink" title="1.API介绍"></a>1.API介绍</h2><h3 id="1-发送通知"><a href="#1-发送通知" class="headerlink" title="1.发送通知"></a>1.发送通知</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyGive</span><span class="params">( TaskHandle_t xTaskToNotify )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyGiveIndexed</span><span class="params">( TaskHandle_t xTaskToNotify, </span></span><br><span class="line"><span class="params">                                    UBaseType_t uxIndexToNotify )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskNotifyGiveFromISR</span><span class="params">( TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                              BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskNotifyGiveIndexedFromISR</span><span class="params">( TaskHandle_t xTaskToNotify, </span></span><br><span class="line"><span class="params">                                     UBaseType_t uxIndexToNotify, </span></span><br><span class="line"><span class="params">                                     BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><em>xTaskToNotify</em></td><td align="center">通知被发给指定的任务的句柄</td></tr><tr><td align="center"><em>uxIndexToNotify</em></td><td align="center">通知的检索值（一个任务可以有多个通知，可以指定放在哪个位置）</td></tr><tr><td align="center">返回值</td><td align="center">一定返回pdPASS</td></tr></tbody></table><h3 id="2-接受通知"><a href="#2-接受通知" class="headerlink" title="2.接受通知"></a>2.接受通知</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyTake</span><span class="params">( BaseType_t xClearCountOnExit,</span></span><br><span class="line"><span class="params">                            TickType_t xTicksToWait )</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyTakeIndexed</span><span class="params">( UBaseType_t uxIndexToWaitOn, </span></span><br><span class="line"><span class="params">                                   BaseType_t xClearCountOnExit, </span></span><br><span class="line"><span class="params">                                   TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">xClearCountOnExit</td><td align="center">可以为pdTRUE和pdFALSE，为pdTRUE时整个通知会被恢复为0</td></tr><tr><td align="center">xTicksToWait</td><td align="center">最大等待时间</td></tr><tr><td align="center">uxIndexToWaitOn</td><td align="center">要等的通知的检索值</td></tr><tr><td align="center">返回值</td><td align="center">返回接受到的通知值</td></tr></tbody></table><p><strong>以上两种发送和接受通知的方式适合作为二进制信号量和计数信号量来使用，因为这相比下面的API来说更加简单。</strong></p><h3 id="3-等待通知"><a href="#3-等待通知" class="headerlink" title="3.等待通知"></a>3.等待通知</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">( <span class="type">uint32_t</span> ulBitsToClearOnEntry,</span></span><br><span class="line"><span class="params">                             <span class="type">uint32_t</span> ulBitsToClearOnExit,</span></span><br><span class="line"><span class="params">                             <span class="type">uint32_t</span> *pulNotificationValue,</span></span><br><span class="line"><span class="params">                             TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyWaitIndexed</span><span class="params">( UBaseType_t uxIndexToWaitOn, </span></span><br><span class="line"><span class="params">                                    <span class="type">uint32_t</span> ulBitsToClearOnEntry, </span></span><br><span class="line"><span class="params">                                    <span class="type">uint32_t</span> ulBitsToClearOnExit, </span></span><br><span class="line"><span class="params">                                    <span class="type">uint32_t</span> *pulNotificationValue, </span></span><br><span class="line"><span class="params">                                    TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ulBitsToClearOnEntry</td><td align="center">进入前清除的位，不清除就填入0x0000</td></tr><tr><td align="center">ulBitsToClearOnExit</td><td align="center">退出前清除的位，不清除则填入0x0000</td></tr><tr><td align="center">pulNotificationValue</td><td align="center">获取通知的值</td></tr><tr><td align="center">xTicksToWait</td><td align="center">最大等待时间</td></tr><tr><td align="center">uxIndexToWaitOn</td><td align="center">等待的消息的检索值</td></tr><tr><td align="center">返回值</td><td align="center">在规定时间获取到则返回pdTRUE，否则返回pdFALSE</td></tr></tbody></table><h3 id="4-发送通知"><a href="#4-发送通知" class="headerlink" title="4.发送通知"></a>4.发送通知</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotify</span><span class="params">( TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                         <span class="type">uint32_t</span> ulValue,</span></span><br><span class="line"><span class="params">                         eNotifyAction eAction )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyIndexed</span><span class="params">( TaskHandle_t xTaskToNotify, </span></span><br><span class="line"><span class="params">                                UBaseType_t uxIndexToNotify, </span></span><br><span class="line"><span class="params">                                <span class="type">uint32_t</span> ulValue, </span></span><br><span class="line"><span class="params">                                eNotifyAction eAction )</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">xTaskToNotify</td><td align="center">通知被发给指定的任务的句柄</td></tr><tr><td align="center">ulValue</td><td align="center">要更改的对方的通知的对应位</td></tr><tr><td align="center">eAction</td><td align="center">对对应位的操作，可以为eIncrement（增加一），eNoAction（不变），eSetBits（对应位置于1），eSetValueWithOverwrite（对应位置1，并且将其他原有为1的位置0），eSetValueWithoutOverwrite（对应位置1，但不把其他原有为1的位置0）</td></tr><tr><td align="center">uxIndexToNotify</td><td align="center">通知的索引值</td></tr><tr><td align="center">返回值</td><td align="center">只可能会返回pdPASS</td></tr></tbody></table><h2 id="2-程序实例"><a href="#2-程序实例" class="headerlink" title="2.程序实例"></a>2.程序实例</h2><h3 id="1-wait与notify"><a href="#1-wait与notify" class="headerlink" title="1. wait与notify"></a>1. wait与notify</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vAnEventProcessingTask</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> ulNotifiedValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">        xTaskNotifyWaitIndexed( <span class="number">0</span>,         <span class="comment">/* 等待第0个通知. */</span></span><br><span class="line">                                <span class="number">0x00</span>,      <span class="comment">/* 在进入时不清除任何位. */</span></span><br><span class="line">                                ULONG_MAX, <span class="comment">/* 在退出前清除所有位. */</span></span><br><span class="line">                                &amp;ulNotifiedValue, <span class="comment">/* 接受到的消息. */</span></span><br><span class="line">                                portMAX_DELAY );  <span class="comment">/* 无限等待. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 处理接受到的消息. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ( ulNotifiedValue &amp; <span class="number">0x01</span> ) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 第0位被置1 - 则触发对应函数. */</span></span><br><span class="line">            prvProcessBit0Event();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ( ulNotifiedValue &amp; <span class="number">0x02</span> ) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 第1位被置1 - 则触发对应函数. */</span></span><br><span class="line">            prvProcessBit1Event();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ( ulNotifiedValue &amp; <span class="number">0x04</span> ) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 第2位被置1 - 则触发对应函数. */</span></span><br><span class="line">            prvProcessBit2Event();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Etc. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-take和give"><a href="#2-take和give" class="headerlink" title="2. take和give"></a>2. take和give</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是一个中断句柄. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vANInterruptHandler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">BaseType_t xHigherPriorityTaskWoken;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clear the interrupt. */</span></span><br><span class="line">    prvClearInterruptSource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* xHigherPriorityTaskWoken must be initialised to pdFALSE.  If calling</span></span><br><span class="line"><span class="comment">    vTaskNotifyGiveFromISR() unblocks the handling task, and the priority of</span></span><br><span class="line"><span class="comment">    the handling task is higher than the priority of the currently running task,</span></span><br><span class="line"><span class="comment">    then xHigherPriorityTaskWoken will automatically get set to pdTRUE. */</span></span><br><span class="line">    xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Unblock the handling task so the task can perform any processing necessitated</span></span><br><span class="line"><span class="comment">    by the interrupt.  xHandlingTask is the task&#x27;s handle, which was obtained</span></span><br><span class="line"><span class="comment">    when the task was created. */</span></span><br><span class="line">    vTaskNotifyGiveIndexedFromISR( xHandlingTask, <span class="number">0</span>, &amp;xHigherPriorityTaskWoken );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Force a context switch if xHigherPriorityTaskWoken is now set to pdTRUE.</span></span><br><span class="line"><span class="comment">    The macro used to do this is dependent on the port and may be called</span></span><br><span class="line"><span class="comment">    portEND_SWITCHING_ISR. */</span></span><br><span class="line">    portYIELD_FROM_ISR( xHigherPriorityTaskWoken );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* A task that blocks waiting to be notified that the peripheral needs servicing,</span></span><br><span class="line"><span class="comment">processing all the events pending in the peripheral each time it is notified to </span></span><br><span class="line"><span class="comment">do so. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vHandlingTask</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">BaseType_t xEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Block indefinitely (without a timeout, so no need to check the function&#x27;s</span></span><br><span class="line"><span class="comment">        return value) to wait for a notification.  Here the RTOS task notification</span></span><br><span class="line"><span class="comment">        is being used as a binary semaphore, so the notification value is cleared</span></span><br><span class="line"><span class="comment">        to zero on exit.  NOTE!  Real applications should not block indefinitely,</span></span><br><span class="line"><span class="comment">        but instead time out occasionally in order to handle error conditions</span></span><br><span class="line"><span class="comment">        that may prevent the interrupt from sending any more notifications. */</span></span><br><span class="line">        ulTaskNotifyTakeIndexed( <span class="number">0</span>,               <span class="comment">/* Use the 0th notification */</span></span><br><span class="line">                                 pdTRUE,          <span class="comment">/* Clear the notification value </span></span><br><span class="line"><span class="comment">                                                     before exiting. */</span></span><br><span class="line">                                 portMAX_DELAY ); <span class="comment">/* Block indefinitely. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The RTOS task notification is used as a binary (as opposed to a</span></span><br><span class="line"><span class="comment">        counting) semaphore, so only go back to wait for further notifications</span></span><br><span class="line"><span class="comment">        when all events pending in the peripheral have been processed. */</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            xEvent = xQueryPeripheral();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( xEvent != NO_MORE_EVENTS )</span><br><span class="line">            &#123;</span><br><span class="line">                vProcessPeripheralEvent( xEvent );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span>( xEvent != NO_MORE_EVENTS );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(十四)--信息缓存</title>
      <link href="/2022/11/02/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%9B%9B-%E4%BF%A1%E6%81%AF%E7%BC%93%E5%AD%98/"/>
      <url>/2022/11/02/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E5%9B%9B-%E4%BF%A1%E6%81%AF%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>Message Buffer是基于Stream Buffer的。只是在每一次发送数据的时候多了四个字节的空间用于存放消息的大小。更具这个消息大小，读取放就可以一次读取出全部消息的内容。在视频中，也会对全部三个FreeRTOS的数据类型进行对比，分别是Queue，Stream Buffer 和 Message Buffer。</p><h2 id="1-API介绍"><a href="#1-API介绍" class="headerlink" title="1.API介绍"></a>1.API介绍</h2><h3 id="1-创建缓存"><a href="#1-创建缓存" class="headerlink" title="1.创建缓存"></a>1.创建缓存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MessageBufferHandle_t <span class="title function_">xMessageBufferCreate</span><span class="params">( <span class="type">size_t</span> xBufferSizeBytes )</span>;</span><br><span class="line"></span><br><span class="line">MessageBufferHandle_t <span class="title function_">xMessageBufferCreateWithCallback</span><span class="params">( </span></span><br><span class="line"><span class="params">                          <span class="type">size_t</span> xBufferSizeBytes,</span></span><br><span class="line"><span class="params">                          StreamBufferCallbackFunction_t pxSendCompletedCallback,</span></span><br><span class="line"><span class="params">                          StreamBufferCallbackFunction_t pxReceiveCompletedCallback )</span>;</span><br><span class="line"></span><br><span class="line">MessageBufferHandle_t <span class="title function_">xMessageBufferCreateStatic</span><span class="params">(</span></span><br><span class="line"><span class="params">                          <span class="type">size_t</span> xBufferSizeBytes,</span></span><br><span class="line"><span class="params">                          <span class="type">uint8_t</span> *pucMessageBufferStorageArea,</span></span><br><span class="line"><span class="params">                          StaticMessageBuffer_t *pxStaticMessageBuffer )</span>;</span><br><span class="line"></span><br><span class="line">MessageBufferHandle_t <span class="title function_">xMessageBufferCreateStaticWithCallback</span><span class="params">(</span></span><br><span class="line"><span class="params">                          <span class="type">size_t</span> xBufferSizeBytes,</span></span><br><span class="line"><span class="params">                          <span class="type">uint8_t</span> *pucMessageBufferStorageArea,</span></span><br><span class="line"><span class="params">                          StaticMessageBuffer_t *pxStaticMessageBuffer,</span></span><br><span class="line"><span class="params">                          StreamBufferCallbackFunction_t pxSendCompletedCallback,</span></span><br><span class="line"><span class="params">                          StreamBufferCallbackFunction_t pxReceiveCompletedCallback )</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">xBufferSizeBytes</td><td align="center">缓存大小</td></tr><tr><td align="center">pxSendCompletedCallback</td><td align="center">发送完成回调函数</td></tr><tr><td align="center">pxReceiveCompletedCallback</td><td align="center">接受完成回调函数</td></tr><tr><td align="center">pucMessageBufferStorageArea</td><td align="center">用于存放要写入到缓存的数据，大小必须比xBufferSizeBytes大一个字节。</td></tr><tr><td align="center">pxStaticMessageBuffer</td><td align="center">存放缓存的内存空间</td></tr><tr><td align="center">返回值</td><td align="center">创建失败返回NULL，成功返回句柄</td></tr></tbody></table><h3 id="2-发送数据到缓存"><a href="#2-发送数据到缓存" class="headerlink" title="2.发送数据到缓存"></a>2.发送数据到缓存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">xMessageBufferSend</span><span class="params">( MessageBufferHandle_t xMessageBuffer,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> <span class="type">void</span> *pvTxData,</span></span><br><span class="line"><span class="params">                           <span class="type">size_t</span> xDataLengthBytes,</span></span><br><span class="line"><span class="params">                           TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">xMessageBufferSendFromISR</span><span class="params">( MessageBufferHandle_t xMessageBuffer,</span></span><br><span class="line"><span class="params">                                  <span class="type">const</span> <span class="type">void</span> *pvTxData,</span></span><br><span class="line"><span class="params">                                  <span class="type">size_t</span> xDataLengthBytes,</span></span><br><span class="line"><span class="params">                                  BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure><p>与 <strong>stream buffer</strong> 的参数同理。</p><h3 id="3-从缓存接受数据"><a href="#3-从缓存接受数据" class="headerlink" title="3.从缓存接受数据"></a>3.从缓存接受数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">xMessageBufferReceive</span><span class="params">( MessageBufferHandle_t xMessageBuffer,</span></span><br><span class="line"><span class="params">                              <span class="type">void</span> *pvRxData,</span></span><br><span class="line"><span class="params">                              <span class="type">size_t</span> xBufferLengthBytes,</span></span><br><span class="line"><span class="params">                              TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">xMessageBufferReceiveFromISR</span><span class="params">( MessageBufferHandle_t xMessageBuffer,</span></span><br><span class="line"><span class="params">                                     <span class="type">void</span> *pvRxData,</span></span><br><span class="line"><span class="params">                                     <span class="type">size_t</span> xBufferLengthBytes,</span></span><br><span class="line"><span class="params">                                     BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure><h3 id="4-删除和重置缓存"><a href="#4-删除和重置缓存" class="headerlink" title="4.删除和重置缓存"></a>4.删除和重置缓存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vMessageBufferDelete</span><span class="params">( MessageBufferHandle_t xMessageBuffer )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xMessageBufferReset</span><span class="params">( MessageBufferHandle_t xMessageBuffer )</span>;</span><br></pre></td></tr></table></figure><h3 id="5-查询状态"><a href="#5-查询状态" class="headerlink" title="5.查询状态"></a>5.查询状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">xMessageBufferSpacesAvailable</span><span class="params">( MessageBufferHandle_t xMessageBuffer )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xMessageBufferIsEmpty</span><span class="params">( MessageBufferHandle_t xMessageBuffer )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xMessageBufferIsFull</span><span class="params">( MessageBufferHandle_t xMessageBuffer )</span>;</span><br></pre></td></tr></table></figure><h2 id="2-代码实例"><a href="#2-代码实例" class="headerlink" title="2.代码实例"></a>2.代码实例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;freertos/message_buffer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MessageBufferHandle_t xMessageBuffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> xMessageBufferSizeBytes = <span class="number">100</span>;</span><br><span class="line">xMessageBuffer = xMessageBufferCreate( xMessageBufferSizeBytes );</span><br><span class="line"></span><br><span class="line">String <span class="title function_">randomGPS</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> gps[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> counter = <span class="number">100</span>;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">switch</span> (random(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="comment">// 返回 经度 纬度 海拔</span></span><br><span class="line">      <span class="built_in">sprintf</span>(gps, <span class="string">&quot;%d-%d-%d-%d&quot;</span>, counter, random(<span class="number">100</span>, <span class="number">999</span>), random(<span class="number">100</span>, <span class="number">999</span>), random(<span class="number">100</span>, <span class="number">999</span>));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="comment">// 返回 经度 纬度</span></span><br><span class="line">      <span class="built_in">sprintf</span>(gps, <span class="string">&quot;%d-%d-%d&quot;</span>, counter, random(<span class="number">100</span>, <span class="number">999</span>), random(<span class="number">100</span>, <span class="number">999</span>));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="comment">// 返回 海拔</span></span><br><span class="line">      <span class="built_in">sprintf</span>(gps, <span class="string">&quot;%d-%d&quot;</span>, counter, random(<span class="number">100</span>, <span class="number">999</span>));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> String(gps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readGPS</span><span class="params">(<span class="type">void</span> * pvParam)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> xBytesSent; <span class="comment">//The number of bytes written to the message buffer.</span></span><br><span class="line">  String gpsInfo;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    gpsInfo = randomGPS(); <span class="comment">//随机发送不同长度的信息</span></span><br><span class="line">    xBytesSent = xMessageBufferSend( xMessageBuffer,</span><br><span class="line">                                     ( <span class="type">void</span> * ) &amp;gpsInfo,</span><br><span class="line">                                     <span class="keyword">sizeof</span>( gpsInfo ),</span><br><span class="line">                                     portMAX_DELAY );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( xBytesSent != <span class="keyword">sizeof</span>( gpsInfo ) )</span><br><span class="line">    &#123;</span><br><span class="line">      Serial.println(<span class="string">&quot;危险: xMessageBufferSend 发送数据不完整&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vTaskDelay(<span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpsDecoder</span><span class="params">(String gpsinfo)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">GPS</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> counter;</span><br><span class="line">    <span class="type">int</span> longVal;</span><br><span class="line">    <span class="type">int</span> latVal;</span><br><span class="line">    <span class="type">int</span> AltVal;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  String s1, s2, s3, s4;</span><br><span class="line">  <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  String gpsinfo2 = gpsinfo;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="type">int</span> index = gpsinfo.indexOf(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (gpsinfo.indexOf(<span class="string">&#x27;-&#x27;</span>) &lt; <span class="number">0</span>) gpsinfo = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    gpsinfo = gpsinfo.substring(index + <span class="number">1</span>, gpsinfo.length());</span><br><span class="line">  &#125; <span class="keyword">while</span> (gpsinfo.length() &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  GPS gps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (counter) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      gps.counter = gpsinfo2.substring(<span class="number">0</span>, <span class="number">3</span>).toInt();</span><br><span class="line">      gps.longVal = <span class="number">-1</span>;</span><br><span class="line">      gps.latVal = <span class="number">-1</span>;</span><br><span class="line">      gps.AltVal = gpsinfo2.substring(<span class="number">4</span>, <span class="number">7</span>).toInt();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      gps.counter = gpsinfo2.substring(<span class="number">0</span>, <span class="number">3</span>).toInt();</span><br><span class="line">      gps.longVal = gpsinfo2.substring(<span class="number">4</span>, <span class="number">7</span>).toInt();</span><br><span class="line">      gps.latVal = gpsinfo2.substring(<span class="number">8</span>, <span class="number">11</span>).toInt();</span><br><span class="line">      gps.AltVal = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      gps.counter = gpsinfo2.substring(<span class="number">0</span>, <span class="number">3</span>).toInt();</span><br><span class="line">      gps.longVal = gpsinfo2.substring(<span class="number">4</span>, <span class="number">7</span>).toInt();</span><br><span class="line">      gps.latVal = gpsinfo2.substring(<span class="number">8</span>, <span class="number">11</span>).toInt();</span><br><span class="line">      gps.AltVal = gpsinfo2.substring(<span class="number">12</span>, <span class="number">15</span>).toInt();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">showGPS</span><span class="params">(<span class="type">void</span> * pvParam)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> xReceivedBytes;</span><br><span class="line">  String gpsInfo;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> xMessageSizeMax = <span class="number">100</span>;</span><br><span class="line">  lcd.init();</span><br><span class="line">  lcd.backlight();</span><br><span class="line">  lcd.setCursor(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  lcd.print(<span class="string">&quot;   GPS INFO&quot;</span>); <span class="comment">//clear this line</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    xReceivedBytes = xMessageBufferReceive( xMessageBuffer,</span><br><span class="line">                                            ( <span class="type">void</span> * ) &amp;gpsInfo,</span><br><span class="line">                                            xMessageSizeMax, <span class="comment">//This sets the maximum length of the message that can be received.</span></span><br><span class="line">                                            portMAX_DELAY );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( xReceivedBytes &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      gpsDecoder(gpsInfo); <span class="comment">//解码，并且显示到屏幕上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vTaskDelay(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(十三)--流媒体缓存</title>
      <link href="/2022/11/02/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%89-%E6%B5%81%E5%AA%92%E4%BD%93%E7%BC%93%E5%AD%98/"/>
      <url>/2022/11/02/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%89-%E6%B5%81%E5%AA%92%E4%BD%93%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>FreeRTOS 10以后引入了一个新的数据类型就是 Stream Buffer。它和Queue最大的不同就是，Stream Buffer读写的大小没有限制，而Queue是预设值好固定的值。Stream Buffer 流媒体缓存顾名思义它的受众对象就是 流媒体 比如MP3，视频，在线电台等。</p><h2 id="1-API介绍"><a href="#1-API介绍" class="headerlink" title="1.API介绍"></a>1.API介绍</h2><h3 id="1-创建缓存"><a href="#1-创建缓存" class="headerlink" title="1.创建缓存"></a>1.创建缓存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StreamBufferHandle_t <span class="title">xStreamBufferCreate</span><span class="params">( <span class="type">size_t</span> xBufferSizeBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">size_t</span> xTriggerLevelBytes )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">StreamBufferHandle_t <span class="title">xStreamBufferCreateWithCallback</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">size_t</span> xBufferSizeBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">size_t</span> xTriggerLevelBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                         StreamBufferCallbackFunction_t pxSendCompletedCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">                         StreamBufferCallbackFunction_t pxReceiveCompletedCallback )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">StreamBufferHandle_t <span class="title">xStreamBufferCreateStatic</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">size_t</span> xBufferSizeBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">size_t</span> xTriggerLevelBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">uint8_t</span> *pucStreamBufferStorageArea,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    StaticStreamBuffer_t *pxStaticStreamBuffer )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">StreamBufferHandle_t <span class="title">xStreamBufferCreateStaticWithCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">size_t</span> xBufferSizeBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">size_t</span> xTriggerLevelBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">uint8_t</span> *pucStreamBufferStorageArea,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    StaticStreamBuffer_t *pxStaticStreamBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    StreamBufferCallbackFunction_t pxSendCompletedCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    StreamBufferCallbackFunction_t pxReceiveCompletedCallback )</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><em>xBufferSizeBytes</em></td><td align="center">一次能接受的最大字节数</td></tr><tr><td align="center"><em>xTriggerLevelBytes</em></td><td align="center">缓存内数据超过这个数值，才会被读取</td></tr><tr><td align="center"><em>pxSendCompletedCallback</em></td><td align="center">发送完成回调函数</td></tr><tr><td align="center"><em>pxReceiveCompletedCallback</em></td><td align="center">接受完成回调函数</td></tr><tr><td align="center">返回值</td><td align="center">返回NULL则内存不够无法创建，成功创建会返回句柄</td></tr></tbody></table><h3 id="2-发送到缓存"><a href="#2-发送到缓存" class="headerlink" title="2.发送到缓存"></a>2.发送到缓存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">xStreamBufferSend</span><span class="params">( StreamBufferHandle_t xStreamBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> <span class="type">void</span> *pvTxData,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">size_t</span> xDataLengthBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TickType_t xTicksToWait )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">xStreamBufferSendFromISR</span><span class="params">( StreamBufferHandle_t xStreamBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> <span class="type">void</span> *pvTxData,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">size_t</span> xDataLengthBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 BaseType_t *pxHigherPriorityTaskWoken )</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><em>xStreamBuffer</em></td><td align="center">要发送到的缓存的句柄</td></tr><tr><td align="center"><em>pvTxData</em></td><td align="center">指向要发送数据的指针</td></tr><tr><td align="center"><em>xDataLengthBytes</em></td><td align="center">向缓存发送的最大字节数</td></tr><tr><td align="center"><em>pxHigherPriorityTaskWoken</em></td><td align="center">可为NULL，让正在等待数据的任务解除阻塞态，并且那个任务的优先级高于此值</td></tr><tr><td align="center">返回值</td><td align="center">有多少字节数据被写到了缓存中</td></tr></tbody></table><h3 id="3-从缓存接受数据"><a href="#3-从缓存接受数据" class="headerlink" title="3.从缓存接受数据"></a>3.从缓存接受数据</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">xStreamBufferReceive</span><span class="params">( StreamBufferHandle_t xStreamBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">void</span> *pvRxData,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">size_t</span> xBufferLengthBytes,<span class="comment">//一次最大接受多少字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             TickType_t xTicksToWait )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">xStreamBufferReceiveFromISR</span><span class="params">( StreamBufferHandle_t xStreamBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">void</span> *pvRxData,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="type">size_t</span> xBufferLengthBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    BaseType_t *pxHigherPriorityTaskWoken )</span></span>;</span><br></pre></td></tr></table></figure><h3 id="4-删除缓存"><a href="#4-删除缓存" class="headerlink" title="4.删除缓存"></a>4.删除缓存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vStreamBufferDelete</span><span class="params">( StreamBufferHandle_t xStreamBuffer )</span></span>;</span><br></pre></td></tr></table></figure><h3 id="5-改变缓存"><a href="#5-改变缓存" class="headerlink" title="5.改变缓存"></a>5.改变缓存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改变已经创建了的缓存的触发阈值</span></span><br><span class="line"><span class="function">BaseType_t <span class="title">xStreamBufferSetTriggerLevel</span><span class="params">( StreamBufferHandle_t xStreamBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">size_t</span> xTriggerLevel )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置缓存，清空所有数据</span></span><br><span class="line"><span class="function">BaseType_t <span class="title">xStreamBufferReset</span><span class="params">( StreamBufferHandle_t xStreamBuffer )</span></span>;</span><br></pre></td></tr></table></figure><h3 id="6-缓存的相关信息"><a href="#6-缓存的相关信息" class="headerlink" title="6.缓存的相关信息"></a>6.缓存的相关信息</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回缓存内还有多少字节数据</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">xStreamBufferBytesAvailable</span><span class="params">( StreamBufferHandle_t xStreamBuffer )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回缓存还剩多少空间</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">xStreamBufferSpacesAvailable</span><span class="params">( StreamBufferHandle_t xStreamBuffer )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存是否为空，返回pdTRUE或者pdFALSE</span></span><br><span class="line"><span class="function">BaseType_t <span class="title">xStreamBufferIsEmpty</span><span class="params">( StreamBufferHandle_t xStreamBuffer )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存是否已满，返回pdTRUE或者pdFALSE</span></span><br><span class="line"><span class="function">BaseType_t <span class="title">xStreamBufferIsFull</span><span class="params">( StreamBufferHandle_t xStreamBuffer )</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-代码实例"><a href="#2-代码实例" class="headerlink" title="2.代码实例"></a>2.代码实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;freertos/stream_buffer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">StreamBufferHandle_t xStreamMusic = <span class="literal">NULL</span>; <span class="comment">//创建一个 Stream Buffer 的 handler</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Stream Buffer的最大尺寸，如果超出可能内存空间，那么创建Stream Buffer就会失败</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> xStreamBufferSizeBytes = <span class="number">540</span>;</span><br><span class="line">  <span class="comment">//Trigger Level - Stream Buffer内数据超过这个数值，才会被读取</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> xTriggerLevel = <span class="number">8</span>;</span><br><span class="line">xStreamMusic = <span class="built_in">xStreamBufferCreate</span>(xStreamBufferSizeBytes, xTriggerLevel);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downloadTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123; <span class="comment">//下载音乐</span></span><br><span class="line">  String music;</span><br><span class="line">  <span class="type">size_t</span> xBytesSent; <span class="comment">//The number of bytes written to the stream buffer.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从网络下载音乐，放一些随机的延迟</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">random</span>(<span class="number">20</span>, <span class="number">40</span>); i++) <span class="built_in">vTaskDelay</span>(<span class="number">1</span>);</span><br><span class="line">    music = <span class="built_in">randomMusic</span>(); <span class="comment">//随机生成一些数据</span></span><br><span class="line"></span><br><span class="line">    xBytesSent = <span class="built_in">xStreamBufferSend</span>( xStreamMusic,</span><br><span class="line">                                    (<span class="type">void</span> *)&amp;music,</span><br><span class="line">                                    <span class="built_in">sizeof</span>(music),</span><br><span class="line">                                    portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( xBytesSent != <span class="built_in">sizeof</span>( music ) ) &#123;</span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;警告: xStreamBufferSend 写入数据出错&quot;</span>);  <span class="comment">//Optional</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vTaskDelay</span>(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">playBackTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123; <span class="comment">//解码并且播放</span></span><br><span class="line">  <span class="type">size_t</span> xReceivedBytes; <span class="comment">//The number of bytes read from the stream buffer.</span></span><br><span class="line">  <span class="type">size_t</span> xReadBytes = <span class="number">8</span>*<span class="number">10</span><span class="number">-1</span>;</span><br><span class="line">  String music;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    xReceivedBytes = <span class="built_in">xStreamBufferReceive</span>( xStreamMusic,</span><br><span class="line">                                           ( <span class="type">void</span> * ) &amp;music,</span><br><span class="line">                                           xReadBytes,</span><br><span class="line">                                           portMAX_DELAY );</span><br><span class="line">    <span class="keyword">if</span> ( xReceivedBytes &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">decode</span>(music);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(十二)--事件标志组</title>
      <link href="/2022/10/29/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%BA%8C-%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84/"/>
      <url>/2022/10/29/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%BA%8C-%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>事件组就是所有任务共享的3个字节(24个位)。事件 “标志 “是一个布尔值（1或0），用于指示一个事件是否发生。事件 “组 “是一组事件标志。事件标志只能为1或0，允许事件标志的状态存储在单个位中，事件组中所有事件标志的状态存储在单个变量中；事件组中每个事件标志的状态由类型为EventBits_t的变量中的单个位表示。因此，事件标志也被称为事件“位”。如果EventBits_t变量中的一位被设为1，则该位表示的事件已经发生。如果在EventBits_t变量中一个位被设置为0。那么由该位表示的事件没有发生。</p><h2 id="2-使用到的API"><a href="#2-使用到的API" class="headerlink" title="2.使用到的API"></a>2.使用到的API</h2><h3 id="1-创建与删除"><a href="#1-创建与删除" class="headerlink" title="1.创建与删除"></a>1.创建与删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventGroupHandle_t <span class="title">xEventGroupCreate</span><span class="params">( <span class="type">void</span> )</span></span>;<span class="comment">//创建事件组，返回的是创建的事件组的句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vEventGroupDelete</span><span class="params">( EventGroupHandle_t xEventGroup )</span></span>;<span class="comment">//删除事件组，传入要删除事件组的句柄</span></span><br></pre></td></tr></table></figure><h3 id="2-等待事件组"><a href="#2-等待事件组" class="headerlink" title="2.等待事件组"></a>2.等待事件组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventBits_t <span class="title">xEventGroupWaitBits</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> EventGroupHandle_t xEventGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> BaseType_t xClearOnExit,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> BaseType_t xWaitForAllBits,</span></span></span><br><span class="line"><span class="params"><span class="function">                       TickType_t xTicksToWait )</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><em>xEventGroup</em></td><td align="center">要等待的事件组的句柄</td></tr><tr><td align="center"><em>uxBitsToWaitFor</em></td><td align="center">要等待事件组的位，如（111）即为等bit0到bit2</td></tr><tr><td align="center"><em>xClearOnExit</em></td><td align="center">是否在等到该位后清除该位</td></tr><tr><td align="center"><em>xWaitForAllBits</em></td><td align="center">当要等多个位时是否要等全部还是等一个</td></tr><tr><td align="center"><em>xTicksToWait</em></td><td align="center">最大等待时间</td></tr><tr><td align="center">返回值</td><td align="center">返回当前事件组的内容</td></tr></tbody></table><h3 id="3-设置事件组"><a href="#3-设置事件组" class="headerlink" title="3.设置事件组"></a>3.设置事件组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set 给对应位置 1</span></span><br><span class="line"><span class="function">EventBits_t <span class="title">xEventGroupSetBits</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> EventBits_t uxBitsToSet )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BaseType_t <span class="title">xEventGroupSetBitsFromISR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                          EventGroupHandle_t xEventGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> EventBits_t uxBitsToSet,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BaseType_t *pxHigherPriorityTaskWoken )</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// clear 给对应位置 0</span></span><br><span class="line"><span class="function">EventBits_t <span class="title">xEventGroupClearBits</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                                 EventGroupHandle_t xEventGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> EventBits_t uxBitsToClear )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BaseType_t <span class="title">xEventGroupClearBitsFromISR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                                EventGroupHandle_t xEventGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">const</span> EventBits_t uxBitsToClear )</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：<strong>BaseType_t <strong>返回pdPASS，或者pdFAIL；</strong>EventBits_t</strong> 返回当前事件组。</p><h3 id="4-同步事件组"><a href="#4-同步事件组" class="headerlink" title="4.同步事件组"></a>4.同步事件组</h3><p>相当于<strong>set</strong>和<strong>wait</strong>的组合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventBits_t <span class="title">xEventGroupSync</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> EventBits_t uxBitsToSet,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TickType_t xTicksToWait )</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><em>xEventGroup</em></td><td align="center">要操作的事件组的句柄</td></tr><tr><td align="center"><em>uxBitsToSet</em></td><td align="center">要设置的位</td></tr><tr><td align="center"><em>uxBitsToWaitFor</em></td><td align="center">要等待的位</td></tr><tr><td align="center"><em>xTicksToWait</em></td><td align="center">最大等待时间</td></tr><tr><td align="center">返回值</td><td align="center">返回当前的事件组</td></tr></tbody></table><h2 id="3-使用实例"><a href="#3-使用实例" class="headerlink" title="3.使用实例"></a>3.使用实例</h2><h3 id="1-不使用sync"><a href="#1-不使用sync" class="headerlink" title="1.不使用sync"></a>1.不使用sync</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADDTOCART_0( 1 &lt;&lt; 0 ) <span class="comment">//0001 bit0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAYMENT_1( 1 &lt;&lt; 1 )  <span class="comment">//0010 bit1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVENTORY_2( 1 &lt;&lt; 2 ) <span class="comment">//0100 bit2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLBITS 0xFFFFFF <span class="comment">//24bits都是1</span></span></span><br><span class="line"></span><br><span class="line">EventGroupHandle_t xEventPurchase = <span class="literal">NULL</span>; <span class="comment">//创建event handler</span></span><br><span class="line">xEventPurchase = <span class="built_in">xEventGroupCreate</span>(); <span class="comment">//创建 event group</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">purchaseTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  EventBits_t uxBits;  <span class="comment">// Event Group 24Bits 的 值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    uxBits = <span class="built_in">xEventGroupSetBits</span>(xEventPurchase, ADDTOCART_0); <span class="comment">// 将bit 0 设置为1</span></span><br><span class="line">    <span class="keyword">if</span> ((uxBits &amp; ADDTOCART_0)) &#123;</span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;商品已经添加到了购物车，付款中...&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;   Event Group Value:&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">println</span>(uxBits, BIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uxBits = <span class="built_in">xEventGroupWaitBits</span> (xEventPurchase,  <span class="comment">//Event Group Handler</span></span><br><span class="line">                                  ADDTOCART_0 | PAYMENT_1 | INVENTORY_2,     <span class="comment">//等待Event Group中的那个Bit(s)</span></span><br><span class="line">                                  pdFALSE,         <span class="comment">//执行后，对应的Bits是否重置为 0</span></span><br><span class="line">                                  pdTRUE,          <span class="comment">//等待的Bits判断关系 True为 AND, False为 OR</span></span><br><span class="line">                                  xTimeOut);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//因为有可能在规定时间内还是无法等到该位，此时程序还是会继续向下，所以要加判断</span></span><br><span class="line">    <span class="keyword">if</span> ((uxBits &amp; ADDTOCART_0) &amp;&amp; (uxBits &amp; PAYMENT_1) &amp;&amp; (uxBits &amp; INVENTORY_2)) &#123;</span><br><span class="line">      <span class="comment">//随机延迟, 模拟网页显示，恭喜买家入手商品</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">random</span>(<span class="number">100</span>, <span class="number">200</span>); i++) <span class="built_in">vTaskDelay</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">xEventGroupClearBits</span>(xEventPurchase, ALLBITS); <span class="comment">//重置</span></span><br><span class="line">      uxBits = <span class="built_in">xEventGroupGetBits</span>(xEventPurchase); <span class="comment">//读取</span></span><br><span class="line"></span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;交易完成, RESET Event Group&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;   Event Group Value:&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">println</span>(uxBits, BIN);</span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//vTaskDelay(10000);</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//         |</span></span><br><span class="line"><span class="comment">//         |</span></span><br><span class="line"><span class="comment">//         V</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paymentTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    EventBits_t uxBits;</span><br><span class="line"></span><br><span class="line">    uxBits = <span class="built_in">xEventGroupWaitBits</span> (xEventPurchase,  <span class="comment">//Event Group Handler</span></span><br><span class="line">                                  ADDTOCART_0,     <span class="comment">//等待Event Group中的那个Bit(s)</span></span><br><span class="line">                                  pdFALSE,         <span class="comment">//执行后，对应的Bits是否重置为 0</span></span><br><span class="line">                                  pdTRUE,          <span class="comment">//等待的Bits判断关系 True为 AND, False为 OR</span></span><br><span class="line">                                  xTimeOut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代表ADDTOCART_0被设置为了 1</span></span><br><span class="line">    <span class="keyword">if</span> (uxBits &amp; ADDTOCART_0) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//随机延迟, 模拟付款验证过程</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">random</span>(<span class="number">100</span>, <span class="number">200</span>); i++) <span class="built_in">vTaskDelay</span>(<span class="number">10</span>);</span><br><span class="line">      uxBits = <span class="built_in">xEventGroupSetBits</span>(xEventPurchase, PAYMENT_1); <span class="comment">// 将bit1 PAYMENT_1 设置为1</span></span><br><span class="line"></span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;支付宝付款完成,可以出货...&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;   Event Group Value:&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">println</span>(uxBits, BIN);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//         |</span></span><br><span class="line"><span class="comment">//         |</span></span><br><span class="line"><span class="comment">//         V</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inventoryTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  EventBits_t uxBits;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    uxBits = <span class="built_in">xEventGroupWaitBits</span> (xEventPurchase,  <span class="comment">//Event Group Handler</span></span><br><span class="line">                                  ADDTOCART_0 | PAYMENT_1,     <span class="comment">//等待Event Group中的那个Bit(s)</span></span><br><span class="line">                                  pdFALSE,         <span class="comment">//执行后，对应的Bits是否重置为 0</span></span><br><span class="line">                                  pdTRUE,          <span class="comment">//等待的Bits判断关系 True为 AND, False为 OR</span></span><br><span class="line">                                  xTimeOut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 Event Group 中 ADDTOCART_0 和 PAYMENT_1 是否被设置为了0</span></span><br><span class="line">    <span class="keyword">if</span> ((uxBits &amp; ADDTOCART_0) &amp;&amp; (uxBits &amp; PAYMENT_1))  &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//随机延迟, 模拟仓库出货过程</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">random</span>(<span class="number">100</span>, <span class="number">200</span>); i++) <span class="built_in">vTaskDelay</span>(<span class="number">10</span>);</span><br><span class="line">      uxBits = <span class="built_in">xEventGroupSetBits</span>(xEventPurchase, INVENTORY_2); <span class="comment">// 将bit2 INVENTORY_2 设置为1</span></span><br><span class="line"></span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;仓库出货完成,快递已取货...&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">print</span>(<span class="string">&quot;   Event Group Value:&quot;</span>);</span><br><span class="line">      Serial.<span class="built_in">println</span>(uxBits, BIN);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用sync"><a href="#2-使用sync" class="headerlink" title="2.使用sync"></a>2.使用sync</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BOUGHT_PAID_SENT (ADDTOCART_0 | PAYMENT_1 | INVENTORY_2)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">purchaseTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  EventBits_t uxBits;  <span class="comment">// Event Group 24Bits 的 值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    uxBits = <span class="built_in">xEventGroupSync</span> (xEventPurchase,  <span class="comment">//Event Group Handler</span></span><br><span class="line">                              ADDTOCART_0,     <span class="comment">// 先将这个bit(s)设置为 1,然后再等待</span></span><br><span class="line">                              BOUGHT_PAID_SENT,  <span class="comment">//等待这些bits为 1</span></span><br><span class="line">                              xTimeOut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((uxBits &amp; BOUGHT_PAID_SENT) == BOUGHT_PAID_SENT)  &#123;</span><br><span class="line">      <span class="comment">//Serial.println(&quot;purchaseTask,已经自我了断. &quot;);</span></span><br><span class="line">      <span class="built_in">xQueueSend</span>(queueMsg, &amp;<span class="string">&quot;END purchaseTask&quot;</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paymentTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  EventBits_t uxBits;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//随机延迟, 模拟付款验证过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">random</span>(<span class="number">100</span>, <span class="number">200</span>); i++) <span class="built_in">vTaskDelay</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//Serial.println(&quot;支付宝付款完成,可以出货...&quot;);</span></span><br><span class="line">    <span class="built_in">xQueueSend</span>(queueMsg, &amp;<span class="string">&quot;Payment Received&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    uxBits = <span class="built_in">xEventGroupSync</span> (xEventPurchase,  <span class="comment">//Event Group Handler</span></span><br><span class="line">                              PAYMENT_1,     <span class="comment">// 先将这个bit(s)设置为 1,然后再等待</span></span><br><span class="line">                              BOUGHT_PAID_SENT,  <span class="comment">//等待这些bits为 1</span></span><br><span class="line">                              xTimeOut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((uxBits &amp; BOUGHT_PAID_SENT) == BOUGHT_PAID_SENT)  &#123;</span><br><span class="line">      <span class="comment">//Serial.println(&quot;paymentTask,已经自我了断. &quot;);</span></span><br><span class="line">      <span class="built_in">xQueueSend</span>(queueMsg, &amp;<span class="string">&quot;END paymentTask&quot;</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inventoryTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  EventBits_t uxBits;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机延迟, 模拟仓库出货过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">random</span>(<span class="number">100</span>, <span class="number">200</span>); i++) <span class="built_in">vTaskDelay</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//Serial.println(&quot;仓库出货完成,快递已取货...&quot;);</span></span><br><span class="line">    <span class="built_in">xQueueSend</span>(queueMsg, &amp;<span class="string">&quot;Inventory Out&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    uxBits = <span class="built_in">xEventGroupSync</span> (xEventPurchase,  <span class="comment">//Event Group Handler</span></span><br><span class="line">                              INVENTORY_2,     <span class="comment">// 先将这个bit(s)设置为 1,然后再等待</span></span><br><span class="line">                              BOUGHT_PAID_SENT,  <span class="comment">//等待这些bits为 1</span></span><br><span class="line">                              xTimeOut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((uxBits &amp; BOUGHT_PAID_SENT) == BOUGHT_PAID_SENT)  &#123;</span><br><span class="line">      <span class="comment">//Serial.println(&quot;inventoryTask,已经自我了断. &quot;);</span></span><br><span class="line">      <span class="built_in">xQueueSend</span>(queueMsg, &amp;<span class="string">&quot;END inventoryTask&quot;</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(十一)--计数信号量</title>
      <link href="/2022/10/29/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%80-%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2022/10/29/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81%E4%B8%80-%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-使用到的API"><a href="#1-使用到的API" class="headerlink" title="1.使用到的API"></a>1.使用到的API</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t xHandler; <span class="comment">//创建Handler</span></span><br><span class="line">xHandler = <span class="built_in">xSemaphoreCreateCounting</span>(uxMaxCount, uxInitialCount); <span class="comment">//创建一个计数信号量 失败返回NULL，成功返回handler</span></span><br><span class="line"><span class="built_in">xSemaphoreGive</span>(xHandler); <span class="comment">//二进制信号量+1</span></span><br><span class="line"><span class="built_in">xSemaphoreTake</span>(xHanlder, timeout); <span class="comment">//二进制信号量-1 返回pdPASS, 或者pdFAIL</span></span><br><span class="line"><span class="built_in">xSemaphoreGiveFromISR</span>(xHandler, portBASE_TYPE *pxHigherPriorityTaskWoken); <span class="comment">//中断里面用的give函数，第二个参数的官方解释如下）</span></span><br></pre></td></tr></table></figure><p><strong>pxHigherPriorityTaskWoken</strong>：对某个信号量而言,可能有不止一个任务处于阻塞态在等待其有效。调用 xSemaphoreGiveFromISR()会让信号量变为有效,所以会让其中一个等待任务切出阻塞态。如果调用 xSemaphoreGiveFromISR()使得一个任务解除阻塞,并且这个任务的优先级高于当前任务(也就是被中断的任务),那么 xSemaphoreGiveFromISR()会在 函 数 内 部 将 *pxHigherPriorityTaskWoken 设为pdTRUE。如果 xSemaphoreGiveFromISR() 将 此 值 设 为pdTRUE,则在中断退出前应当进行一次上下文切换。这样才能保证中断直接返回到就绪态任务中优先级最高的任务中。</p><h2 id="2-具体使用例"><a href="#2-具体使用例" class="headerlink" title="2.具体使用例"></a>2.具体使用例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t xSemaPhone = <span class="literal">NULL</span>;</span><br><span class="line">xSemaPhone = <span class="built_in">xSemaphoreCreateCounting</span>(<span class="number">3</span>, <span class="number">0</span>);<span class="comment">//创建一个最大为3，初始值为0的计数信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">void</span> *paParam)</span> </span>&#123; <span class="comment">//制造者 give</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">random</span>(<span class="number">100</span>, <span class="number">200</span>); i++) <span class="built_in">vTaskDelay</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">xSemaphoreGive</span>(xSemaPhone);</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;...... 手机再放出一台,&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123; <span class="comment">//消费者 take</span></span><br><span class="line">  String website = *(String *)pvParam;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xSemaphoreTake</span>(xSemaPhone, portMAX_DELAY) == pdTRUE ) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">random</span>(<span class="number">200</span>, <span class="number">400</span>); i++) <span class="built_in">vTaskDelay</span>(<span class="number">10</span>);</span><br><span class="line">      Serial.<span class="built_in">print</span>(website);</span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;抢到并销售一台: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(十)--二进制信号量</title>
      <link href="/2022/10/27/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2022/10/27/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-使用到的API"><a href="#1-使用到的API" class="headerlink" title="1.使用到的API"></a>1.使用到的API</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t xHandler; <span class="comment">//创建Handler</span></span><br><span class="line">xHandler = <span class="built_in">xSemaphoreCreateBinary</span>(); <span class="comment">//创建一个二进制信号量 返回NULL，或者handler</span></span><br><span class="line"><span class="built_in">xSemaphoreGive</span>(xHandler); <span class="comment">//二进制信号量+1</span></span><br><span class="line"><span class="built_in">xSemaphoreTake</span>(xHanlder, timeout); <span class="comment">//二进制信号量-1 返回pdPASS, 或者pdFAIL</span></span><br><span class="line"><span class="built_in">xSemaphoreGiveFromISR</span>(xHandler, portBASE_TYPE *pxHigherPriorityTaskWoken); <span class="comment">//中断里面用的give函数，第二个参数的官方解释如下）</span></span><br></pre></td></tr></table></figure><p><strong>pxHigherPriorityTaskWoken</strong>：对某个信号量而言,可能有不止一个任务处于阻塞态在等待其有效。调用 xSemaphoreGiveFromISR()会让信号量变为有效,所以会让其中一个等待任务切出阻塞态。如果调用 xSemaphoreGiveFromISR()使得一个任务解除阻塞,并且这个任务的优先级高于当前任务(也就是被中断的任务),那么 xSemaphoreGiveFromISR()会在 函 数 内 部 将 *pxHigherPriorityTaskWoken 设为pdTRUE。如果 xSemaphoreGiveFromISR() 将 此 值 设 为pdTRUE,则在中断退出前应当进行一次上下文切换。这样才能保证中断直接返回到就绪态任务中优先级最高的任务中。</p><h2 id="2-使用案例（按键控制LED开关）"><a href="#2-使用案例（按键控制LED开关）" class="headerlink" title="2.使用案例（按键控制LED开关）"></a>2.使用案例（按键控制LED开关）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">flashLED</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pinMode</span>(<span class="number">23</span>, OUTPUT);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//当信号量为1时则take就会返回pdPASS，并且信号量-1变为0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xSemaphoreTake</span>( xSemaLED, timeOut) == pdPASS )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">xTaskGetTickCount</span>() - btnDeounce) &lt; <span class="number">100</span>) &#123; <span class="comment">//用于button debounce</span></span><br><span class="line">        <span class="built_in">digitalWrite</span>(<span class="number">23</span>, !<span class="built_in">digitalRead</span>(<span class="number">23</span>));</span><br><span class="line">        <span class="built_in">vTaskDelay</span>(<span class="number">1000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readBtn</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pinMode</span>(<span class="number">22</span>, INPUT_PULLUP);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">digitalRead</span>(<span class="number">22</span>) == LOW) &#123;</span><br><span class="line">      <span class="built_in">xSemaphoreGive</span>(xSemaLED);<span class="comment">//信号量+1（1+1还是1）当信号量已经为1时还give就会返回pdFAIL</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//OR 写成中断</span></span><br><span class="line"><span class="built_in">attachInterrupt</span>(<span class="number">22</span>, ISR, FALLING);</span><br><span class="line"><span class="function"><span class="type">void</span> IRAM_ATTR <span class="title">ISR</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  btnDeounce = <span class="built_in">xTaskGetTickCountFromISR</span>();</span><br><span class="line">  <span class="built_in">xSemaphoreGiveFromISR</span>(xSemaLED, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过镜像恢复方式为nanopi配置系统</title>
      <link href="/2022/10/27/%E9%80%9A%E8%BF%87%E9%95%9C%E5%83%8F%E6%81%A2%E5%A4%8D%E6%96%B9%E5%BC%8F%E4%B8%BAnanopi%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/10/27/%E9%80%9A%E8%BF%87%E9%95%9C%E5%83%8F%E6%81%A2%E5%A4%8D%E6%96%B9%E5%BC%8F%E4%B8%BAnanopi%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-请烧录如下固件"><a href="#1-请烧录如下固件" class="headerlink" title="1.请烧录如下固件"></a>1.请烧录如下固件</h2><p><code>nanopi-neo-core_eflasher_friendlycore-xenial_4.14_armhf_YYYYMMDD.img.zip</code></p><p>烧录完的SD卡将会有以下三个分区(SD必须大于16G)</p><ul><li>boot</li><li>rootfs</li><li>FriendlyARM</li></ul><p>Windows下可能需要相关软件才能读取到所有分区。</p><h2 id="2-通过串口控制nanopi"><a href="#2-通过串口控制nanopi" class="headerlink" title="2.通过串口控制nanopi"></a>2.通过串口控制nanopi</h2><p>请按照图示连接nanopi，串口请连接到UART0，波特率必须为115200</p><p><img src="https://wiki.friendlyelec.com/wiki/images/5/53/NEO_Core_pinout-02.jpg"></p><p><img src="https://wiki.friendlyelec.com/wiki/images/b/b4/USB2UART-NEO-Core.jpg"></p><p>插入SD卡，并通过串口连接到电脑进入终端（如果串口显示为空可以尝试回车几次）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">普通用户：</span><br><span class="line">用户名: pi</span><br><span class="line">密码: pi</span><br><span class="line"></span><br><span class="line">Root用户：</span><br><span class="line">用户名: root</span><br><span class="line">密码: fa</span><br></pre></td></tr></table></figure><p>在终端以超级管理员身份执行指令 <code>eflasher</code> 后有如下界面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------------------</span><br><span class="line">  EFlasher v1.2 b190111 running on NanoPC-T4</span><br><span class="line">    Doc: http://wiki.friendlyelec.com/wiki/index.php/EFlasher</span><br><span class="line">    eMMC: 14.56 GB</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Select an OS to install:</span></span><br><span class="line">    1) Android 8</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Select your backup target device:</span></span><br><span class="line">     tf) [*] TF card  (/dev/mmcblk0p1 - 4.27 GB free - 5.67 GB total - fuseblk)</span><br><span class="line">    usb) [ ] USB disk  (&lt;none&gt;)</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Backup eMMC flash to TF card:</span></span><br><span class="line">    Not enough free disk space on your TF card</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Restore eMMC flash from backup file:</span></span><br><span class="line">    No backup files found</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Configure automatic job:</span></span><br><span class="line">    aui) Automatic installing (Curr:Off)</span><br><span class="line">    aur) Automatic restoring (Curr:Off)</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">Format drive</span></span><br><span class="line">    ftf) Format TF card back to original size</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Enter an option (1/tf/usb/aui/aur/ftf) :</span></span><br></pre></td></tr></table></figure><p>若SD卡为第一次使用请先输入ftf，然后关机转至电脑，向SD第三个分区放入 <code>nanopi-neo-core-emmc.raw</code> 备份文件再重新开启并进入 nanopi 执行 <code>r1</code> 选项，否则直接输入 <code>r1</code> 选项并回车即可烧写镜像。</p><p>注意：烧写完后的nanopi为<code>静态ip 192.168.137.219</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> JMU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(九)--队列在任务间传输数据</title>
      <link href="/2022/10/26/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B9%9D-%E9%98%9F%E5%88%97%E5%9C%A8%E4%BB%BB%E5%8A%A1%E9%97%B4%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/10/26/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B9%9D-%E9%98%9F%E5%88%97%E5%9C%A8%E4%BB%BB%E5%8A%A1%E9%97%B4%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-队列相关的API"><a href="#1-队列相关的API" class="headerlink" title="1.队列相关的API"></a>1.队列相关的API</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个队列</span></span><br><span class="line"><span class="function">QueueHandle_t <span class="title">xQueueCreate</span><span class="params">( UBaseType_t uxQueueLength,<span class="comment">//队列数据单元深度</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             UBaseType_t uxItemSize<span class="comment">//每个数据单元有多少字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">                          )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列里发数据</span></span><br><span class="line"><span class="function">BaseType_t <span class="title">xQueueSend</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                      QueueHandle_t xQueue,<span class="comment">//队列的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> <span class="type">void</span> * pvItemToQueue,<span class="comment">//要向队列写入的数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">                      TickType_t xTicksToWait<span class="comment">//最长等待时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">                      )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从队列里取数据</span></span><br><span class="line"><span class="function">BaseType_t <span class="title">xQueueReceive</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                            QueueHandle_t xQueue,<span class="comment">//队列的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">void</span> *pvBuffer,<span class="comment">//传入要用于接受数据的变量</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            TickType_t xTicksToWait<span class="comment">//最长等待时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">                        )</span></span>;</span><br></pre></td></tr></table></figure><h2 id="2-使用案例"><a href="#2-使用案例" class="headerlink" title="2.使用案例"></a>2.使用案例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义数据类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sensor_t</span>&#123;</span><br><span class="line">  byte deviceID;</span><br><span class="line">  <span class="type">float</span> value1;</span><br><span class="line">  <span class="type">float</span> value2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建队列</span></span><br><span class="line">QueueHandle_t queueSensor = <span class="built_in">xQueueCreate</span>(<span class="number">8</span>, <span class="built_in">sizeof</span>(<span class="type">sensor_t</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备好数据</span></span><br><span class="line"><span class="type">sensor_t</span> dht22Sensor;</span><br><span class="line">dht22Sensor.value1 = dht22.temperature;</span><br><span class="line">dht22Sensor.value2 = dht22.humidity;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列写入数据，如果返回的不是pdPASS则表示队列已满（在规定的timeOut时间内无法写入到队列内数据则会返回 errQUEUE_FULL )</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">xQueueSend</span>(queueSensor, &amp;dht22Sensor, timeOut) != pdPASS)</span><br><span class="line">&#123;</span><br><span class="line">      Serial.<span class="built_in">println</span>(<span class="string">&quot;DHT22: Queue is full.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取队列中的数据，如果队列中没有数据则返回 errQUEUE_FULL )</span></span><br><span class="line"><span class="type">sensor_t</span> data;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">xQueueReceive</span>(queueSensor, &amp;data, timeOut) == pdPASS)</span><br><span class="line">&#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(data.value1);</span><br><span class="line">    Serial.<span class="built_in">println</span>(data.value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(八)--看门狗</title>
      <link href="/2022/10/25/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AB-%E7%9C%8B%E9%97%A8%E7%8B%97/"/>
      <url>/2022/10/25/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AB-%E7%9C%8B%E9%97%A8%E7%8B%97/</url>
      
        <content type="html"><![CDATA[<p> 需要知道的是：</p><ul><li>Arduion-ESP32 默认在 Core 0 的 IDLE 任务开启了看门狗 时间为 5000 ticks &#x3D; 5秒（若IDLE(0)无法运行，所以不能喂狗，将导致系统5秒后重启）</li><li>Core 0 和 Core 1 都运行了 FreeRTOS 的IDLE任务，优先级为 0（IDLE任务是用于清理被删除任务的内存）</li><li>Core 1 loopBack任务就是Arduino的 setup 和 loop 优先级为 1</li></ul><p>API：需要包含 <em>esp_task_wdt.h</em> 文件</p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">esp_task_wdt_init</td><td align="center">初始化任务看门狗计时器</td></tr><tr><td align="center">esp_task_wdt_deinit</td><td align="center">取消初始化任务监视计时器</td></tr><tr><td align="center">esp_task_wdt_add</td><td align="center">将任务订阅到任务监视计时器</td></tr><tr><td align="center">esp_task_wdt_reset</td><td align="center">当前正在运行的任务重置任务看门狗计时器</td></tr><tr><td align="center">esp_task_wdt_delete</td><td align="center">从任务监视计时器取消订阅任务</td></tr><tr><td align="center">esp_task_wdt_status</td><td align="center">查询任务是否已订阅任务监视程序计时器</td></tr></tbody></table><p>官方使用例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_task_wdt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a_task</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">esp_task_wdt_add</span>(<span class="literal">NULL</span>);<span class="comment">//给当前任务添加看门狗</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">esp_task_wdt_reset</span>();<span class="comment">//喂狗</span></span><br><span class="line">        <span class="built_in">vTaskDelay</span>(<span class="built_in">pdMS_TO_TICKS</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">esp_task_wdt_delete</span>(<span class="literal">NULL</span>);<span class="comment">//删除当前任务的看门狗</span></span><br><span class="line">    <span class="built_in">vTaskDelete</span>(<span class="literal">NULL</span>);<span class="comment">//删除自身任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">app_mian</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">esp_task_wdt_init</span>(TWDT_TIMEOUT_S, <span class="literal">false</span>);<span class="comment">//arduino上不需要init，因为官方已经写到你程序前面了</span></span><br><span class="line">    <span class="built_in">esp_task_wdt_add</span>(<span class="built_in">xTaskGetIdleTaskHandleForCPU</span>(<span class="number">0</span>));<span class="comment">//为IDLE开启任务看门狗</span></span><br><span class="line">    <span class="built_in">esp_task_wdt_delete</span>(<span class="built_in">xTaskGetIdleTaskHandleForCPU</span>(<span class="number">0</span>));<span class="comment">//删除IDLE任务的看门狗</span></span><br><span class="line">    <span class="built_in">esp_task_wdt_status</span>(<span class="built_in">xTaskGetIdleTaskHandleForCPU</span>(<span class="number">0</span>));<span class="comment">//因为IDLE任务看门狗被删除所以会返回ESP_ERR_NOT_FOUND</span></span><br><span class="line">    <span class="built_in">esp_task_wdt_deinit</span>();<span class="comment">//关闭任务看门狗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出给所有狗喂食的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//feedTheDogInAllTasks()</span></span><br><span class="line"><span class="comment">//通过寄存器给所有任务的狗喂时</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;soc/timer_group_struct.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;soc/timer_group_reg.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">feedTheDogInAllTasks</span><span class="params">()</span> </span>&#123; <span class="comment">//通过寄存器给所有任务的狗喂时</span></span><br><span class="line">  <span class="comment">// feed dog 0</span></span><br><span class="line">  TIMERG0.wdt_wprotect = TIMG_WDT_WKEY_VALUE; <span class="comment">// write enable</span></span><br><span class="line">  TIMERG0.wdt_feed = <span class="number">1</span>;                     <span class="comment">// feed dog</span></span><br><span class="line">  TIMERG0.wdt_wprotect = <span class="number">0</span>;                 <span class="comment">// write protect</span></span><br><span class="line">  <span class="comment">// feed dog 1</span></span><br><span class="line">  TIMERG1.wdt_wprotect = TIMG_WDT_WKEY_VALUE; <span class="comment">// write enable</span></span><br><span class="line">  TIMERG1.wdt_feed = <span class="number">1</span>;                     <span class="comment">// feed dog</span></span><br><span class="line">  TIMERG1.wdt_wprotect = <span class="number">0</span>;                 <span class="comment">// write protect</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(七)--任务优先级</title>
      <link href="/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%83-%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%83-%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p> 在ESP32上的FreeRTOS上优先级越高其值越大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">API：</span><br><span class="line">    <span class="comment">//设置优先级</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">vTaskPrioritySet</span><span class="params">( TaskHandle_t xTask, UBaseType_t uxNewPriority )</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取TashHandle任务优先级</span></span><br><span class="line">    <span class="function">UBaseType_t <span class="title">uxTaskPriorityGet</span><span class="params">( TaskHandle_t xTask )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前任务优先级</span></span><br><span class="line">    <span class="function">UBaseType_t <span class="title">uxTaskPriorityGet</span><span class="params">(<span class="literal">NULL</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退让资源，任务调度器会重新评估任务，将资源分配给同等级或者更高等级任务</span></span><br><span class="line">    <span class="comment">//注意不会把资源给低等级任务</span></span><br><span class="line">    <span class="built_in">tastYIELD</span>();</span><br></pre></td></tr></table></figure><p>当高优先级的任务没有阻塞或者挂起时，同一核心的低优先级的任务将得不到运行，这就是为什么要用 vTaskDelay 的原因了 ——— 让任务进入阻塞，而普通的delay将没有这样的效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(六)--任务的状态和管理</title>
      <link href="/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AD-%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AD-%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p> 介绍了任务的全部状态和对相关任务进行管理。</p><h2 id="1-任务的状态"><a href="#1-任务的状态" class="headerlink" title="1.任务的状态"></a>1.任务的状态</h2><ul><li><p>Blocked阻塞态</p><p>任务会在进入block的函数处停止，并且不占用CPU资源</p></li><li><p>Suspended挂起态</p><p>任务会完全暂停，不占用CPU资源</p></li><li><p>Ready就绪态</p><p>准备运行该任务</p></li><li><p>Running运行态</p><p>任务运行中</p></li></ul><h2 id="2-任务的管理"><a href="#2-任务的管理" class="headerlink" title="2.任务的管理"></a>2.任务的管理</h2><p>会使用到如下函数API：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xTaskCreate</span><span class="params">(,,,,,)</span></span>; <span class="comment">//任务创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vTaskDelete</span><span class="params">( TaskHandle_t xTask )</span></span>; <span class="comment">//任务删除 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vTaskSuspend</span><span class="params">( TaskHandle_t xTaskToSuspend )</span></span>; <span class="comment">//任务暂停</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vTaskResume</span><span class="params">( TaskHandle_t xTaskToResume )</span></span>; <span class="comment">//任务恢复</span></span><br><span class="line"><span class="comment">//相关参数都为要操作任务的句柄，为NULL时则操作当前任务</span></span><br></pre></td></tr></table></figure><p>下面是使用实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t theTestHandle = <span class="literal">NULL</span>; <span class="comment">//Task Handler</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">xTaskCreate</span>(radioBilibili, <span class="string">&quot;The　test code&quot;</span>, <span class="number">1024</span> * <span class="number">8</span>, <span class="literal">NULL</span>, <span class="number">1</span>, &amp;theTestHandle);<span class="comment">//创建任务</span></span><br><span class="line"><span class="built_in">vTaskSuspend</span>(theTestHandle);<span class="comment">//挂起任务</span></span><br><span class="line"><span class="built_in">vTaskDelay</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">vTaskResume</span>(theTestHandle);<span class="comment">//恢复任务</span></span><br><span class="line"><span class="built_in">vTaskDelete</span>(theTestHandle);<span class="comment">//删除任务</span></span><br><span class="line">theTestHandle = <span class="literal">NULL</span>; <span class="comment">//最后还需要手动将handler设置为空</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(五)--任务内存优化</title>
      <link href="/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94-%E4%BB%BB%E5%8A%A1%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
      <url>/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94-%E4%BB%BB%E5%8A%A1%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p> 介绍了如何获取剩余内存堆空间，如何准确分配内存。</p><h2 id="1-获取剩余内存堆空间"><a href="#1-获取剩余内存堆空间" class="headerlink" title="1.获取剩余内存堆空间"></a>1.获取剩余内存堆空间</h2><p>下面两个是由ESP官方提供的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ESP.<span class="built_in">getHeapSize</span>()<span class="comment">//获取ESP32的总堆空间，返回int</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ESP.<span class="built_in">getFreeHeap</span>()<span class="comment">//获取ESP32剩余堆空间，返回int</span></span><br></pre></td></tr></table></figure><p>下面介绍获取单个任务的剩余堆空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uxTaskGetStackHighWaterMark</span><span class="params">(taskHandle)</span><span class="comment">//获取指定任务的剩余内存，参数为NULL时获取当前任务的剩余内存</span></span></span><br></pre></td></tr></table></figure><p>下面是一个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> heapSize = ESP.<span class="built_in">getHeapSize</span>();</span><br><span class="line">Serial.<span class="built_in">print</span>(<span class="string">&quot;Total Heap Size:  &quot;</span>);</span><br><span class="line">Serial.<span class="built_in">print</span>(heapSize);</span><br><span class="line">Serial.<span class="built_in">println</span>(<span class="string">&quot; Bytes&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> heapFree = ESP.<span class="built_in">getFreeHeap</span>();</span><br><span class="line">Serial.<span class="built_in">print</span>(<span class="string">&quot;Free Heap Size:  &quot;</span>);</span><br><span class="line">Serial.<span class="built_in">print</span>(heapFree);</span><br><span class="line">Serial.<span class="built_in">println</span>(<span class="string">&quot; Bytes&quot;</span>);</span><br><span class="line">Serial.<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> taskMem = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">xTaskCreate</span>(task, <span class="string">&quot;&quot;</span>, taskMem, <span class="literal">NULL</span>, <span class="number">1</span>, &amp;taskHandle);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vTaskDelay</span>(<span class="number">2000</span>);<span class="comment">//如果在任务刚创建就获取剩余内存那么结果将会不准</span></span><br><span class="line"><span class="type">int</span> waterMark = <span class="built_in">uxTaskGetStackHighWaterMark</span>(taskHandle);</span><br><span class="line">Serial.<span class="built_in">print</span>(<span class="string">&quot;Task Free Memory: &quot;</span>);</span><br><span class="line">Serial.<span class="built_in">print</span>(waterMark);</span><br><span class="line">Serial.<span class="built_in">println</span>(<span class="string">&quot; Bytes&quot;</span>);</span><br><span class="line">Serial.<span class="built_in">print</span>(<span class="string">&quot;Task Used Memory: &quot;</span>);</span><br><span class="line">Serial.<span class="built_in">print</span>(taskMem - waterMark);</span><br><span class="line">Serial.<span class="built_in">println</span>(<span class="string">&quot; Bytes&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="2-正确分配内存"><a href="#2-正确分配内存" class="headerlink" title="2.正确分配内存"></a>2.正确分配内存</h2><p>提供获取剩余内存来算出任务使用的内存，再将xTaskCreate的对应参数设置为使用内存的2倍是较为保险的设置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(二)--MUTEX互斥量的应用</title>
      <link href="/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-MUTEX%E4%BA%92%E6%96%A5%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-MUTEX%E4%BA%92%E6%96%A5%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>包括任务函数使用全局变量和添加互斥量避免“冒险与竞争”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用前的准备</span></span><br><span class="line">SemaphoreHandle_t xMutextheTestTask = <span class="literal">NULL</span>; <span class="comment">//创建信号量Handler</span></span><br><span class="line">TickType_t timeOut = <span class="number">1000</span>; <span class="comment">//用于获取信号量的Timeout 1000 ticks</span></span><br><span class="line">xMutextheTestTask = <span class="built_in">xSemaphoreCreateMutex</span>(); <span class="comment">//创建MUTEX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">theTestTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在timeout时间内任务会block来等待获取到密钥(返回NULL则获取失败)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xSemaphoreTake</span>(xMutextheTestTask, timeOut) == pdPASS) &#123;</span><br><span class="line">        <span class="comment">//写入被保护的数据，这个过程需要尽可能快</span></span><br><span class="line">        <span class="built_in">xSemaphoreGive</span>(xMutextheTestTask); <span class="comment">//释放钥匙</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用到的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">xSemaphoreCreateMutex</span>();</span><br><span class="line"><span class="comment">//创建信号量，返回 SemaphoreHandle_t 句柄用于调用该互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">xSemaphoreTake</span>(xMutextheTestTask, timeOut);</span><br><span class="line"><span class="comment">//获取互斥量，xMutextheTestTask为互斥量的句柄，timeOut为最长等待获取时间，等待期间任务会block</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">xSemaphoreGive</span>(xMutextheTestTask);</span><br><span class="line"><span class="comment">//释放互斥量，xMutextheTestTask为互斥量的句柄，之后别人才能获取到互斥量</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(三)--任务等待绝对的时间</title>
      <link href="/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89-%E4%BB%BB%E5%8A%A1%E7%AD%89%E5%BE%85%E7%BB%9D%E5%AF%B9%E7%9A%84%E6%97%B6%E9%97%B4/"/>
      <url>/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89-%E4%BB%BB%E5%8A%A1%E7%AD%89%E5%BE%85%E7%BB%9D%E5%AF%B9%E7%9A%84%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>在任务中我们可以使用 vTaskDelay(pdTICKS_TO_MS(delayTimeMS)) 来延时对应时间，但是实际上这个延迟将会有误差，如果我们的任务对频率要求更高的话就可以使用如下函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vTaskDelayUntil</span>(&amp;xLastWakeTime, xFrequency);</span><br><span class="line"><span class="comment">//xLastWakeTime为调用该函数时的tickCount，xFrequency为需要等待的tick，期间函数将会阻塞，结束时tickCount的值会为xLastWakeTime + xFrequency</span></span><br></pre></td></tr></table></figure><p>下面是使用样例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用前准备</span></span><br><span class="line"><span class="comment">//最后一次唤醒的tick count，第一次使用需要赋值</span></span><br><span class="line"><span class="comment">//以后此变量会由vTaskDelayUntil自动更新</span></span><br><span class="line">TickType_t xLastWakeTime = <span class="built_in">xTaskGetTickCount</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> TickType_t xFrequency = <span class="built_in">pdTICKS_TO_MS</span>(<span class="number">1000</span>); <span class="comment">// 间隔 1000 ms = 3 seconds</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用延迟函数</span></span><br><span class="line">Serial.<span class="built_in">println</span>(<span class="built_in">xTaskGetTickCount</span>());</span><br><span class="line"><span class="built_in">vTaskDelayUntil</span>(&amp;xLastWakeTime, xFrequency);</span><br><span class="line">Serial.<span class="built_in">println</span>(<span class="built_in">xTaskGetTickCount</span>());<span class="comment">//可以看到TickCount加了xFrequency</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(四)--软件定时器的应用</title>
      <link href="/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>先介绍创建软件定时器的API函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimerHandle_t <span class="title">xTimerCreate</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> TickType_t xTimerPeriodInTicks,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> UBaseType_t uxAutoReload,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">void</span> * <span class="type">const</span> pvTimerID,</span></span></span><br><span class="line"><span class="params"><span class="function">                            TimerCallbackFunction_t pxCallbackFunction )</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pcTimerName</td><td>定时器名字，用于调试目的，方便识别不同的定时器。</td></tr><tr><td>xTimerPeriodInTicks</td><td>定时器周期，单位系统时钟Tick。</td></tr><tr><td>uxAutoReload</td><td>选择周期模式还是单次模式，若参数为pdTRUE，则表示选择周期模式，若参数为pdFALSE，则表示选择单次模式。（自动重装载值）</td></tr><tr><td>pvTimerID</td><td>是定时器ID，当创建不同的定时器，但使用相同的<a href="https://so.csdn.net/so/search?q=%E5%9B%9E%E8%B0%83&spm=1001.2101.3001.7020">回调</a>函数时，在回调函数中通过不同的ID号来区分不同的定时器。</td></tr><tr><td>pxCallbackFunction</td><td>定时器回调函数。</td></tr><tr><td>返回值</td><td>创建成功返回定时器的句柄，由于FreeRTOSCongfig.h文件中heap空间不足，或者定时器周期设置为0，会返回NULL。</td></tr></tbody></table><p>还有其他的函数配合使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">xTimerStart</span>(timerHandle, timeOutTick)</span><br><span class="line"><span class="comment">//timerHandle为需要开启的定时器的句柄</span></span><br><span class="line"><span class="comment">//timeOutTick表示如果定时器被占用时需要等待的时间，最大值为portMAX_DELAY</span></span><br><span class="line"><span class="comment">//成功开启定时器返回pdPASS</span></span><br></pre></td></tr></table></figure><p>下面是使用实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用前准备</span></span><br><span class="line">TimerHandle_t theTimerHandle;</span><br><span class="line">theTimerHandle = <span class="built_in">xTimerCreate</span>(<span class="string">&quot;the test&quot;</span>,</span><br><span class="line">                            <span class="number">2000</span>,<span class="comment">//延迟2000个Tick</span></span><br><span class="line">                            pdFALSE,<span class="comment">//不要自动重载</span></span><br><span class="line">                            (<span class="type">void</span> *)<span class="number">0</span>,<span class="comment">//定时器ID，因为要传入void指针，所以要强制转换</span></span><br><span class="line">                            theTestCallback);<span class="comment">//计时结束后要调用的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正式使用定时器</span></span><br><span class="line"><span class="built_in">xTimerStart</span>(theTimerHandle, portMAX_DELAY);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESP32-FreeRTOS学习笔记(一)--创建FreeRTOS任务</title>
      <link href="/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%88%9B%E5%BB%BAFreeRTOS%E4%BB%BB%E5%8A%A1/"/>
      <url>/2022/10/21/ESP32-FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%88%9B%E5%BB%BAFreeRTOS%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>包括任务的创建和向任务传参</p><h2 id="1-创建任务"><a href="#1-创建任务" class="headerlink" title="1.创建任务"></a>1.创建任务</h2><p>任务调用的函数模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">theTestTask</span><span class="params">(<span class="type">void</span> *pvParam)</span> </span>&#123;</span><br><span class="line"><span class="comment">//your code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任务是由 C 语言函数实现的。唯一特别的只是任务的函数原型，其必须返回 void， 而且带有一个 void 指针参数。</p><p>调用FreeRTOS提供的函数创建任务</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vportBASE_TYPE <span class="title">xTaskCreate</span><span class="params">( pdTASK_CODE pvTaskCode, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">signed</span> portCHAR * <span class="type">const</span> pcName, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">unsigned</span> portSHORT usStackDepth, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> *pvParameters, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">unsigned</span> portBASE_TYPE uxPriority, </span></span></span><br><span class="line"><span class="params"><span class="function">xTaskHandle *pxCreatedTask )</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th align="left">描述</th></tr></thead><tbody><tr><td>pvTaskCode</td><td align="left">指向你要运行的函数的指针</td></tr><tr><td>pcName</td><td align="left">具有描述性的任务名。这个参数不会被 FreeRTOS 使用。其只是单 纯地用于辅助调试。识别一个具有可读性的名字总是比通过句柄来 识别容易得多。</td></tr><tr><td>usStackDepth</td><td align="left">用于告诉内核为它分配多大的栈空间,单位是字节（byte）。注意，这与原版FreeRTOS不同，原版为字（word）。</td></tr><tr><td>pvParameters</td><td align="left">传向任务函数的参数</td></tr><tr><td>uxPriority</td><td align="left">指定任务执行的优先级。优先级的取值范围可以从最低优先级 0 到 最高优先级(configMAX_PRIORITIES – 1)。需要注意的是值越大优先级越高。</td></tr><tr><td>pxCreatedTask</td><td align="left">用于传出任务的句柄。这个句柄将在 API 调用中对 该创建出来的任务进行引用，比如改变任务优先级，或者删除任务。不需要则可以为NULL。</td></tr><tr><td>返回值</td><td align="left">成功创建则为 pdTRUE , 若为errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY 则表示栈空间不足无法创建。</td></tr></tbody></table><p>因为ESP32为双核MCU，所以还提供了 xTaskCreatePinnedToCore 函数用于指定在哪个核心上运行，只需在正常 xTaskCreate 最后参数后面再加个 const BaseType_t xCoreID 参数，函数名改为 xTaskCreatePinnedToCore 即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">xTaskCreatePinnedToCore</span>(theTestTask, <span class="string">&quot;For test&quot;</span>, <span class="number">1024</span>, <span class="literal">NULL</span>, <span class="number">1</span>, &amp;theTaskHandle, <span class="number">1</span>);<span class="comment">//指定到了CORE1运行该任务</span></span><br></pre></td></tr></table></figure><p>需要知道的是,ESP32的WiFi相关程序会运行在CORE0，如果在连续使用WiFi时又在CORE0跑任务将会导致WiFi出现各种问题。第二点，Arduino的setup函数和loop函数是运行在CORE1的一个FreeRTOS任务，如果并不需要使用到这几个函数，则也可以删除该任务。</p><h2 id="2-向任务函数传参"><a href="#2-向任务函数传参" class="headerlink" title="2.向任务函数传参"></a>2.向任务函数传参</h2><p>举一个向任务函数传递结构体的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LEDFLASH</span>&#123;</span><br><span class="line">  byte pin;</span><br><span class="line">  <span class="type">int</span> delayTime;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义任务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ledFlash</span><span class="params">(<span class="type">void</span> *pt)</span> </span>&#123;</span><br><span class="line">  LEDFLASH * ptLedFlash = (LEDFLASH *)pt;<span class="comment">//将void指针转为结构体指针</span></span><br><span class="line">  byte pin = ptLedFlash-&gt;pin;</span><br><span class="line">  <span class="type">int</span> delayTime = ptLedFlash-&gt;delayTime;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pinMode</span>(pin,OUTPUT);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">digitalWrite</span>(pin, !<span class="built_in">digitalRead</span>(pin));</span><br><span class="line">    <span class="built_in">vTaskDelay</span>(delayTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建任务线程</span></span><br><span class="line">LEDFLASH led1;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">xTaskCreate</span>(ledFlash,</span><br><span class="line">                  <span class="string">&quot;FLASH LED&quot;</span>,</span><br><span class="line">                  <span class="number">1024</span>,</span><br><span class="line">                  (<span class="type">void</span> *)&amp;led1,</span><br><span class="line">                  <span class="number">1</span>,</span><br><span class="line">                  <span class="literal">NULL</span>) == pdPASS)</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;led1 flash task Created.&quot;</span>);</span><br></pre></td></tr></table></figure><p>其中出现了 vTaskDelay(delayTick) 函数，表示任务block阻塞指定时间，在ESP32上一个Tick等于一个ms，但是我依然推荐规范写法 vTaskDelay(delayTimeMS &#x2F; portTICK_RATE_MS) 或者 vTaskDelay(pdTICKS_TO_MS(delayTimeMS))</p>]]></content>
      
      
      
        <tags>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下给单片机烧录程序时提示没有权限</title>
      <link href="/2022/09/21/linux%E4%B8%8B%E7%BB%99%E5%8D%95%E7%89%87%E6%9C%BA%E7%83%A7%E5%BD%95%E7%A8%8B%E5%BA%8F%E6%97%B6%E6%8F%90%E7%A4%BA%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90/"/>
      <url>/2022/09/21/linux%E4%B8%8B%E7%BB%99%E5%8D%95%E7%89%87%E6%9C%BA%E7%83%A7%E5%BD%95%E7%A8%8B%E5%BA%8F%E6%97%B6%E6%8F%90%E7%A4%BA%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p>  这是因为该用户所在的用户组不包含USB的相关权限，我们可以将用户添加到有权限的用户组，或者将对应串口开放给所有人使用。</p><h2 id="1-添加到dialout用户组"><a href="#1-添加到dialout用户组" class="headerlink" title="1. 添加到dialout用户组"></a>1. 添加到dialout用户组</h2><p>打开终端输入:<code>sudo usermod -aG dialout USERNAME</code></p><h2 id="2-开放串口权限"><a href="#2-开放串口权限" class="headerlink" title="2. 开放串口权限"></a>2. 开放串口权限</h2><p>添加如下内容到 <em>&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;</em> 下的rules文件:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KERNEL==“ttyACM[0-9]*”, MODE=“0666”</span><br><span class="line">KERNEL==“ttyUSB[0-9]*”, MODE=“0666”</span><br></pre></td></tr></table></figure><p>最好自己创建一个新文件,名称要符合规范。</p><h2 id="3-单独给串口开放权限"><a href="#3-单独给串口开放权限" class="headerlink" title="3. 单独给串口开放权限"></a>3. 单独给串口开放权限</h2><p>使用管理员权限:</p><p><code>sudo chmod 777 /dev/ttyACM0</code></p><p>缺点是每次插拔设备后都需要重新更改权限。</p>]]></content>
      
      
      
        <tags>
            
            <tag> arduino platformio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++下返回引用类型的函数</title>
      <link href="/2022/09/17/C-%E4%B8%8B%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0/"/>
      <url>/2022/09/17/C-%E4%B8%8B%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-先申明一个类"><a href="#1-先申明一个类" class="headerlink" title="1. 先申明一个类"></a>1. 先申明一个类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a, <span class="type">int</span> b);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Test&amp; <span class="title">addA</span><span class="params">(Test &amp;t)</span></span>;<span class="comment">//返回值为Test类的引用，传入参数为Test的引用</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setA</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setB</span><span class="params">(<span class="type">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-定义一个函数"><a href="#2-定义一个函数" class="headerlink" title="2. 定义一个函数"></a>2. 定义一个函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Test&amp; <span class="title">Test::addA</span><span class="params">(Test&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = t.<span class="built_in">getA</span>();</span><br><span class="line">    <span class="keyword">this</span> -&gt; a += a;<span class="comment">//即使两个变量名称一样，但this指针区分了这两个变量</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回整个对象本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-具体应用"><a href="#3-具体应用" class="headerlink" title="3. 具体应用"></a>3. 具体应用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> A, <span class="type">int</span> B):<span class="built_in">a</span>(A), <span class="built_in">b</span>(B)&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Test&amp; <span class="title">addA</span><span class="params">(Test &amp;t)</span></span>;<span class="comment">//返回值为Test类的引用，传入参数为Test的引用</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getA</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span> -&gt; a;&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getB</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span> -&gt; b;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test&amp; <span class="title">Test::addA</span><span class="params">(Test&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = t.<span class="built_in">getA</span>();</span><br><span class="line">    <span class="keyword">this</span> -&gt; a += a;<span class="comment">//即使两个变量名称一样，但this指针区分了这两个变量</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回整个对象本身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;before: &quot;</span> &lt;&lt; t1.<span class="built_in">getA</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    t1.<span class="built_in">addA</span>(t2).<span class="built_in">addA</span>(t2).<span class="built_in">addA</span>(t2);  </span><br><span class="line">    <span class="comment">//t1的a加了3次t2的a，最后等于1+3+3+3 = 10,如果没有返回引用则只能加一次，就不能像这样套娃了</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;after: &quot;</span> &lt;&lt; t1.<span class="built_in">getA</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aroma香气(阿罗马)安装教程</title>
      <link href="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-判断你的机器状态"><a href="#1-判断你的机器状态" class="headerlink" title="1.判断你的机器状态"></a>1.判断你的机器状态</h2><ul><li>是否已经破解？<ul><li>提拉米苏破解<ol><li>则直接拷贝增量包至SD卡根目录,提示覆盖则选择覆盖</li><li>将SD卡插入机器后,如果你的机器已经设置了开机启动提拉米苏,则在开机的同时按住<em><strong>X</strong></em>键进入选单选择<em><strong>aroma</strong></em>即可进入阿罗马系统.</li></ol></li><li>脑锻炼破解，网页(固化)破解,冷启动破解等等<ol><li>进入下面的破解步骤(如果为冷启动要先卸载冷启动)</li></ol></li></ul></li></ul><h2 id="2-破解前的准备"><a href="#2-破解前的准备" class="headerlink" title="2. 破解前的准备"></a>2. 破解前的准备</h2><ul><li>容量大于4GB的SD卡</li><li>带有PAD的WIIU</li><li>良好的网络</li><li>提前备份好机器的NAND</li></ul><ol><li>以FAT32格式化SD卡后下载<em><strong>Aroma(阿罗马)整合包</strong></em>的压缩文件并解压到SD卡根目录.</li><li>保证SD卡根目录有<em><strong>wiiu</strong></em>文件夹.</li><li>将SD卡插入机器并开机.</li><li>在桌面选择进入浏览器,这将会有两种情况:<ul><li>如果你为脑锻炼固化破解,则需要手动输入<em><strong>wiiuexploit.xyz</strong></em>这个网址并进入,待网页完全加载完之后后点击<strong>Run Exploit</strong>按钮即可.</li><li>如果你为网页破解(固化),则按照正常进入破解的方式即可.</li></ul></li><li>这时你应该能成功进入<em><strong>Environment Loader</strong></em>选单(黑色界面如下),如果卡死请强制重启之后继续尝试.</li></ol><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/1.jpg"></p><ol start="6"><li>选择第二项<em><strong>installer</strong></em>,并进入到如下界面.</li></ol><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/2.jpg"></p><ol start="7"><li>点击<em><strong>check</strong></em>,并进入如下界面.</li></ol><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/3.jpg"></p><ol start="8"><li>点击<em><strong>Install &#x2F; update</strong></em>,并进入如下界面.</li></ol><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/4.jpg"></p><ol start="9"><li>点击<em><strong>Install</strong></em>,并进入如下界面.</li></ol><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/5.jpg"></p><ol start="10"><li>按<em><strong>A</strong></em>即可关闭主机.</li><li>待主机完全关闭后再打开主机.</li><li>在桌面上找到<strong>健康与安全程序</strong>(⚠️)如下,点击进入.</li></ol><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/6.jpg"></p><p>14.在如下选单中光标移动到<em><strong>aroma</strong></em>后按<strong>Y</strong>,后移动到<em><strong>install</strong></em>上按<strong>A</strong>.</p><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/1.jpg"></p><p>15.进入到如下界面后点击<em><strong>check</strong></em>.</p><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/2.jpg"></p><ol start="16"><li>下图选择<em><strong>Boot options</strong></em>,然后按照提示按<strong>A</strong>,最后机器自动关机.</li></ol><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/3.jpg"></p><p>17.再次开启机器后应该会直接进入到如下界面,请移动到<em><strong>Wii U Menu</strong></em>选项后先按<strong>Y</strong>后按<strong>A</strong>.</p><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/9.jpg"></p><p>如果为红色警告页面如下,请按<strong>B</strong>忽略.</p><p><img src="/2022/09/09/Aroma%E9%A6%99%E6%B0%94-%E9%98%BF%E7%BD%97%E9%A9%AC-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/8.jpg"></p><ol start="18"><li>然后你应该就已经顺利进入桌面了,破解到此结束.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> wiiu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在C语言下在结构体内加入函数</title>
      <link href="/2022/09/08/%E5%9C%A8C%E8%AF%AD%E8%A8%80%E4%B8%8B%E5%9C%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%8A%A0%E5%85%A5%E5%87%BD%E6%95%B0/"/>
      <url>/2022/09/08/%E5%9C%A8C%E8%AF%AD%E8%A8%80%E4%B8%8B%E5%9C%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%8A%A0%E5%85%A5%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><p>Class类与Struct结构体最大的区别可能就是内部能不能有函数，在C语言下结构体虽然不能直接加入函数，但是我们可以通过指针曲线救国。</p><p>先来看一个函数指针的例子(来自c++ primer plus):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">betsy</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pam</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimate</span><span class="params">(<span class="type">int</span> lines,<span class="type">double</span> (*pf)(<span class="type">int</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> code;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;line of code : &quot;</span>;</span><br><span class="line">cin &gt;&gt; code;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;betsy time : &quot;</span>;</span><br><span class="line"><span class="built_in">estimate</span>(code, betsy);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pam time : &quot;</span>;</span><br><span class="line"><span class="built_in">estimate</span>(code, pam);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">betsy</span><span class="params">(<span class="type">int</span> lns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.05</span> * lns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">pam</span><span class="params">(<span class="type">int</span> lns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.03</span> *lns;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">estimate</span><span class="params">(<span class="type">int</span> lines, <span class="type">double</span> (*pf)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">cout &lt;&lt; lines &lt;&lt; <span class="string">&quot; lines will take &quot;</span>;</span><br><span class="line">cout &lt;&lt; (*pf)(lines) &lt;&lt; <span class="string">&quot; hours \n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="开始实例"><a href="#开始实例" class="headerlink" title="开始实例"></a>开始实例</h2><p>现在开始我们的实例先创建下面的这个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">void</span> (*show)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以像这样初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fxf</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> <span class="title">test1</span>=</span>&#123;<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, *fxf&#125;;</span><br></pre></td></tr></table></figure><p>最后贴上完整代码，代码最终运行了一个结构体“中”的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">void</span> (*show)();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*cur_task)();</span><br><span class="line"><span class="type">void</span> <span class="title function_">fxf</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fxf&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> <span class="title">test1</span>;</span></span><br><span class="line">test1.show = fxf;<span class="comment">//函数名就是指针</span></span><br><span class="line">cur_task = test1.show;</span><br><span class="line">(*cur_task)();<span class="comment">//最终运行了fxf这个函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个函数指针 <em><strong>cur_task</strong></em> 和 <em><strong>show</strong></em> 后面的参数不必与 <em><strong>fxf</strong></em> 函数的一样。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
